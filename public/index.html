<html lang="en">
<head>
  <meta charset="utf-8">
  <title>xx</title>
  <meta name="description" content="xx">
  <meta name="author" content="xx">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css"
    integrity="sha512-xh6O/CkQoPOWDdYTDqeRdPCVd1SpvCA9XXcUnZS2FmJNp1coAFzvtCN9BmamE+4aHK8yyUHUSCcJHgXloTyT2A==" 
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Titillium+Web&display=swap" rel="stylesheet"> 
  <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
  <article>
    <section data-class="frameset catalogue" data-file="catalogue" data-id="index" data-title="Ya">
<embed type="application/transclusion" src="catalogue,intro" />
</section>
<section data-class="frameset catalogue" data-file="catalogue" data-id="list" data-title="Ya">
<embed type="application/transclusion" src="dimensions/interaction,summary" />
<embed type="application/transclusion" src="dimensions/notation,summary" />
</section>
<section data-file="catalogue" data-id="intro" data-title="Catalogue of technical dimensions">
<h1>Catalogue of technical dimensions</h1>
<p>The technical dimensions framework breaks down discussion about
programming systems along various specific "axes". The dimensions identify
a range of possible design choices, characterized by two extreme points
in the design space.</p>
<p><a href="#image=catalogue,nest"><img src="img/nest.png" alt="A diagram showing programming systems with two dimensions" /></a></p>
<p>The dimensions are not quantitative, but they allow qualitative comparison.
The extreme points do not represent "good" and "bad" designs, merely different trade-offs.</p>
<p>The set of dimensions provides a map of the design space of programming systems (see the
illustration). Past and present systems serve as landmarks, but the map also reveals unexplored
or overlooked possibilities.</p>
<p>The 22 technical dimensions are grouped into 7 clusters or topics of interest.
Each cluster consists of individual dimensions, examples that capture a particular
known value (or a combination of values), remarks and relations to other dimensions.</p>
<!--
- <i class="fa fa-hand-pointer"></i> Interaction
- <i class="fa fa-code"></i> Notation
- <i class="fa fa-cubes"></i> Conceptual structure
- <i class="fa fa-hammer"></i> Customizability
- <i class="fa fa-sitemap"></i> Complexity
- <i class="fa fa-bug"></i> Errors
- <i class="fa fa-code-fork"></i> Adoptability
-->
</section>
<section data-class="noborder" data-file="catalogue" data-id="nest" data-title="An illustration of the technical dimensions framework">
<blockquote>
<p><img src="img/nest.png" alt="A diagram showing programming systems with two dimensions" /></p>
<p><strong>Illustration of technical dimensions.</strong> The diagram shows a number of sample programming
systems, positioned according to two hypothetical dimensions. Viewed as programming systems,
text-based programming languages with debugger, editor and build tools are grouped
in one region.</p>
</blockquote>
</section>
<section data-class="welcome" data-file="index" data-id="welcome" data-title="Technical dimensions of programming systems">
<h1>Technical dimensions of programming systems</h1>
<blockquote>
<p>by <a href="https://programmingmadecomplicated.wordpress.com/">Joel Jakubovic</a>, <a href="https://alarmingdevelopment.org/">Jonathan Edwards</a> and <a href="https://tomasp.net">Tomas Petricek</a></p>
</blockquote>
<p><a href="#image=index,smalltalk-76"><img src="img/smalltalk-76.png" alt="A screenshot of the Smalltalk 76 programming environment" /></a></p>
<p>Programming is done in a stateful environment, by interacting with a system through a
graphical user interface. The stateful, interactive and graphical environment is more
important than the programming language(s) used through it. Yet, most research focuses on comparing and
studying <em>programming languages</em> and only little has been said about <em>programming systems</em>.</p>
<p>Technical dimensions is a framework that captures the characteristics of programming
systems. It makes it possible to compare programming systems, better understand them,
and to find interesting new points in the design space of programming systems.
We created technical dimensions to help designers of programming systems to evaluate,
compare and guide their work and, ultimately, stand on the shoulders of giants.</p>
<h2>Where to start to learn more</h2>
<ul>
<li>
Want to delve into the details and analyse your system?<br />
<a class="tlink" href="#top=catalogue,index;left=catalogue,list;footer=index,navigation"><i class="fa fa-arrow-right"></i>Start from the catalogue of technical dimensions</a>
</li>
<li>
Want to explore our framework by example?<br />
<a class="tlink" href="#left=index,systems"><i class="fa fa-arrow-right"></i>Start from good old programming systems</a>
</li>
<li>
Want to see how this helps us understand programming systems?<br />
<a class="tlink" href="#left=index,matrix-intro;big=index,matrix-body;footer=index,navigation"><i class="fa fa-arrow-right"></i>Start from a summary matrix of system and dimensions</a>
</li>
<li>
Want to understand our motivation and methodology?<br />
<a class="tlink" href="#left=paper,main"><i class="fa fa-arrow-right"></i>Start from our paper about technical dimensions</a>
</li>
</ul>
</section>
<section data-file="index" data-id="smalltalk-76" data-title="Smalltalk 76 programming environment">
<blockquote>
<p><img src="img/smalltalk-76.png" alt="A screenshot of the Smalltalk 76 programming environment" /></p>
<p><strong>Smalltalk 76 programming environment.</strong> An example of a stateful programming environment with
rich graphical user interface. In Smalltalk, the developer environment is a part of an executing
program and the state of the program can be edited through object browser.</p>
</blockquote>
</section>
<section data-file="index" data-id="navigation" data-title="Where to go to learn more">
<div>
<ul>
<li>
Want to delve into the details and analyse your system?<br />
<a class="tlink" href="#top=catalogue,index;left=catalogue,list;footer=index,navigation"><i class="fa fa-arrow-right"></i>Start from the catalogue of technical dimensions</a>
</li>
<li>
Want to explore our framework by example?<br />
<a class="tlink" href="#left=index,systems"><i class="fa fa-arrow-right"></i>Start from good old programming systems</a>
</li>
<li>
Want to see how this helps us understand programming systems?<br />
<a class="tlink" href="#left=index,matrix-intro;big=index,matrix-body;footer=index,navigation"><i class="fa fa-arrow-right"></i>Start from a summary matrix of system and dimensions</a>
</li>
<li>
Want to understand our motivation and methodology?<br />
<a class="tlink" href="#left=paper,main"><i class="fa fa-arrow-right"></i>Start from our paper about technical dimensions</a>
</li>
<li>
Want to the Technical Dimensions welcome page?<br />
<a class="tlink" href="#splash=index,welcome"><i class="fa fa-arrow-right"></i>Go back and choose a different route</a>
</li>
</ul>
</div>
</section>
<section data-file="index" data-id="matrix-intro" data-title="Summary matrix of systems and dimensions">
<h1>Matrix of systems and dimensions</h1>
<p>The matrix shows the differences between <a href="#left=index,systems">good old programming systems</a>
along the dimensions identified by our framework. For conciseness, the table shows only one
row for each cluster of dimensions, which consists of multiple separate dimensions each.</p>
<p>The header colors are used to mark systems that are similar (in an informal sense)
for a given dimension. Icons indicate a speficic characteristics and should help you
find connections between systems. You can click on the header to go to a relevant
paper section, but note that not all cases are discussed in the paper.</p>
</section>
<section data-class="matrix" data-file="index" data-id="matrix-body" data-title="Detailed matrix of systems and dimensions">
<div class="table-wrapper"><table><tr><th></th><th class='slisp-machines'>LISP machines</th><th class='ssmalltalk'>Smalltalk</th><th class='sunix'>UNIX</th><th class='sspreadsheets'>Spreadsheets</th><th class='sweb'>Web platform</th><th class='shypercard'>Hypercard</th><th class='sboxer'>Boxer</th><th class='snotebooks'>Notebooks</th><th class='shaskell'>Haskell</th></tr><tr class='dinteraction'><th>Interaction</th><td class='slisp-machines'><embed type="application/transclusion" src="systems/lisp-machines,dims-interaction" data-links="#left=index,matrix;right=systems/lisp-machines,index" /></td><td class='ssmalltalk'><embed type="application/transclusion" src="systems/smalltalk,dims-interaction" data-links="#left=index,matrix;right=systems/smalltalk,index" /></td><td class='sunix'><embed type="application/transclusion" src="systems/unix,dims-interaction" data-links="#left=index,matrix;right=systems/unix,index" /></td><td class='sspreadsheets'><embed type="application/transclusion" src="systems/spreadsheets,dims-interaction" data-links="#left=index,matrix;right=systems/spreadsheets,index" /></td><td class='sweb'><embed type="application/transclusion" src="systems/web,dims-interaction" data-links="#left=index,matrix;right=systems/web,index" /></td><td class='shypercard'><embed type="application/transclusion" src="systems/hypercard,dims-interaction" data-links="#left=index,matrix;right=systems/hypercard,index" /></td><td class='sboxer'><embed type="application/transclusion" src="systems/boxer,dims-interaction" data-links="#left=index,matrix;right=systems/boxer,index" /></td><td class='snotebooks'><embed type="application/transclusion" src="systems/notebooks,dims-interaction" data-links="#left=index,matrix;right=systems/notebooks,index" /></td><td class='shaskell'><embed type="application/transclusion" src="systems/haskell,dims-interaction" data-links="#left=index,matrix;right=systems/haskell,index" /></td></tr><tr class='dnotation'><th>Notation</th><td class='slisp-machines'><embed type="application/transclusion" src="systems/lisp-machines,dims-notation" data-links="#left=index,matrix;right=systems/lisp-machines,index" /></td><td class='ssmalltalk'><embed type="application/transclusion" src="systems/smalltalk,dims-notation" data-links="#left=index,matrix;right=systems/smalltalk,index" /></td><td class='sunix'><embed type="application/transclusion" src="systems/unix,dims-notation" data-links="#left=index,matrix;right=systems/unix,index" /></td><td class='sspreadsheets'><embed type="application/transclusion" src="systems/spreadsheets,dims-notation" data-links="#left=index,matrix;right=systems/spreadsheets,index" /></td><td class='sweb'><embed type="application/transclusion" src="systems/web,dims-notation" data-links="#left=index,matrix;right=systems/web,index" /></td><td class='shypercard'><embed type="application/transclusion" src="systems/hypercard,dims-notation" data-links="#left=index,matrix;right=systems/hypercard,index" /></td><td class='sboxer'><embed type="application/transclusion" src="systems/boxer,dims-notation" data-links="#left=index,matrix;right=systems/boxer,index" /></td><td class='snotebooks'><embed type="application/transclusion" src="systems/notebooks,dims-notation" data-links="#left=index,matrix;right=systems/notebooks,index" /></td><td class='shaskell'><embed type="application/transclusion" src="systems/haskell,dims-notation" data-links="#left=index,matrix;right=systems/haskell,index" /></td></tr><tr class='dconceptual'><th>Conceptual structure</th><td class='slisp-machines'><embed type="application/transclusion" src="systems/lisp-machines,dims-conceptual" data-links="#left=index,matrix;right=systems/lisp-machines,index" /></td><td class='ssmalltalk'><embed type="application/transclusion" src="systems/smalltalk,dims-conceptual" data-links="#left=index,matrix;right=systems/smalltalk,index" /></td><td class='sunix'><embed type="application/transclusion" src="systems/unix,dims-conceptual" data-links="#left=index,matrix;right=systems/unix,index" /></td><td class='sspreadsheets'><embed type="application/transclusion" src="systems/spreadsheets,dims-conceptual" data-links="#left=index,matrix;right=systems/spreadsheets,index" /></td><td class='sweb'><embed type="application/transclusion" src="systems/web,dims-conceptual" data-links="#left=index,matrix;right=systems/web,index" /></td><td class='shypercard'><embed type="application/transclusion" src="systems/hypercard,dims-conceptual" data-links="#left=index,matrix;right=systems/hypercard,index" /></td><td class='sboxer'><embed type="application/transclusion" src="systems/boxer,dims-conceptual" data-links="#left=index,matrix;right=systems/boxer,index" /></td><td class='snotebooks'><embed type="application/transclusion" src="systems/notebooks,dims-conceptual" data-links="#left=index,matrix;right=systems/notebooks,index" /></td><td class='shaskell'><embed type="application/transclusion" src="systems/haskell,dims-conceptual" data-links="#left=index,matrix;right=systems/haskell,index" /></td></tr><tr class='dcustomizability'><th>Customizability</th><td class='slisp-machines'><embed type="application/transclusion" src="systems/lisp-machines,dims-customizability" data-links="#left=index,matrix;right=systems/lisp-machines,index" /></td><td class='ssmalltalk'><embed type="application/transclusion" src="systems/smalltalk,dims-customizability" data-links="#left=index,matrix;right=systems/smalltalk,index" /></td><td class='sunix'><embed type="application/transclusion" src="systems/unix,dims-customizability" data-links="#left=index,matrix;right=systems/unix,index" /></td><td class='sspreadsheets'><embed type="application/transclusion" src="systems/spreadsheets,dims-customizability" data-links="#left=index,matrix;right=systems/spreadsheets,index" /></td><td class='sweb'><embed type="application/transclusion" src="systems/web,dims-customizability" data-links="#left=index,matrix;right=systems/web,index" /></td><td class='shypercard'><embed type="application/transclusion" src="systems/hypercard,dims-customizability" data-links="#left=index,matrix;right=systems/hypercard,index" /></td><td class='sboxer'><embed type="application/transclusion" src="systems/boxer,dims-customizability" data-links="#left=index,matrix;right=systems/boxer,index" /></td><td class='snotebooks'><embed type="application/transclusion" src="systems/notebooks,dims-customizability" data-links="#left=index,matrix;right=systems/notebooks,index" /></td><td class='shaskell'><embed type="application/transclusion" src="systems/haskell,dims-customizability" data-links="#left=index,matrix;right=systems/haskell,index" /></td></tr><tr class='dcomplexity'><th>Complexity</th><td class='slisp-machines'><embed type="application/transclusion" src="systems/lisp-machines,dims-complexity" data-links="#left=index,matrix;right=systems/lisp-machines,index" /></td><td class='ssmalltalk'><embed type="application/transclusion" src="systems/smalltalk,dims-complexity" data-links="#left=index,matrix;right=systems/smalltalk,index" /></td><td class='sunix'><embed type="application/transclusion" src="systems/unix,dims-complexity" data-links="#left=index,matrix;right=systems/unix,index" /></td><td class='sspreadsheets'><embed type="application/transclusion" src="systems/spreadsheets,dims-complexity" data-links="#left=index,matrix;right=systems/spreadsheets,index" /></td><td class='sweb'><embed type="application/transclusion" src="systems/web,dims-complexity" data-links="#left=index,matrix;right=systems/web,index" /></td><td class='shypercard'><embed type="application/transclusion" src="systems/hypercard,dims-complexity" data-links="#left=index,matrix;right=systems/hypercard,index" /></td><td class='sboxer'><embed type="application/transclusion" src="systems/boxer,dims-complexity" data-links="#left=index,matrix;right=systems/boxer,index" /></td><td class='snotebooks'><embed type="application/transclusion" src="systems/notebooks,dims-complexity" data-links="#left=index,matrix;right=systems/notebooks,index" /></td><td class='shaskell'><embed type="application/transclusion" src="systems/haskell,dims-complexity" data-links="#left=index,matrix;right=systems/haskell,index" /></td></tr><tr class='derrors'><th>Errors</th><td class='slisp-machines'><embed type="application/transclusion" src="systems/lisp-machines,dims-errors" data-links="#left=index,matrix;right=systems/lisp-machines,index" /></td><td class='ssmalltalk'><embed type="application/transclusion" src="systems/smalltalk,dims-errors" data-links="#left=index,matrix;right=systems/smalltalk,index" /></td><td class='sunix'><embed type="application/transclusion" src="systems/unix,dims-errors" data-links="#left=index,matrix;right=systems/unix,index" /></td><td class='sspreadsheets'><embed type="application/transclusion" src="systems/spreadsheets,dims-errors" data-links="#left=index,matrix;right=systems/spreadsheets,index" /></td><td class='sweb'><embed type="application/transclusion" src="systems/web,dims-errors" data-links="#left=index,matrix;right=systems/web,index" /></td><td class='shypercard'><embed type="application/transclusion" src="systems/hypercard,dims-errors" data-links="#left=index,matrix;right=systems/hypercard,index" /></td><td class='sboxer'><embed type="application/transclusion" src="systems/boxer,dims-errors" data-links="#left=index,matrix;right=systems/boxer,index" /></td><td class='snotebooks'><embed type="application/transclusion" src="systems/notebooks,dims-errors" data-links="#left=index,matrix;right=systems/notebooks,index" /></td><td class='shaskell'><embed type="application/transclusion" src="systems/haskell,dims-errors" data-links="#left=index,matrix;right=systems/haskell,index" /></td></tr><tr class='dadoptability'><th>Adoptability</th><td class='slisp-machines'><embed type="application/transclusion" src="systems/lisp-machines,dims-adoptability" data-links="#left=index,matrix;right=systems/lisp-machines,index" /></td><td class='ssmalltalk'><embed type="application/transclusion" src="systems/smalltalk,dims-adoptability" data-links="#left=index,matrix;right=systems/smalltalk,index" /></td><td class='sunix'><embed type="application/transclusion" src="systems/unix,dims-adoptability" data-links="#left=index,matrix;right=systems/unix,index" /></td><td class='sspreadsheets'><embed type="application/transclusion" src="systems/spreadsheets,dims-adoptability" data-links="#left=index,matrix;right=systems/spreadsheets,index" /></td><td class='sweb'><embed type="application/transclusion" src="systems/web,dims-adoptability" data-links="#left=index,matrix;right=systems/web,index" /></td><td class='shypercard'><embed type="application/transclusion" src="systems/hypercard,dims-adoptability" data-links="#left=index,matrix;right=systems/hypercard,index" /></td><td class='sboxer'><embed type="application/transclusion" src="systems/boxer,dims-adoptability" data-links="#left=index,matrix;right=systems/boxer,index" /></td><td class='snotebooks'><embed type="application/transclusion" src="systems/notebooks,dims-adoptability" data-links="#left=index,matrix;right=systems/notebooks,index" /></td><td class='shaskell'><embed type="application/transclusion" src="systems/haskell,dims-adoptability" data-links="#left=index,matrix;right=systems/haskell,index" /></td></tr></table></div>
<h2>Select systems and dimensions to compare in the table</h2>
<div class="matrix-footer">
<p>For example, you may want to compare different systems of a certain type such as
OS-like systems (LISP machines, Smalltalk, UNIX, Web),
sysems built around languages (Haskell, Notebooks)
or application-focused systems (spreadsheets, Hypercard, Boxer).</p>
</div>
<div class="checksgroup">
<div class="checks">
<p>
<button onclick="[...document.getElementsByClassName('csys')].forEach(function(e) { e.checked=true; if (e.onchange) e.onchange(); });">Select all</button> 
<button onclick="[...document.getElementsByClassName('csys')].forEach(function(e) { e.checked=false; if (e.onchange) e.onchange(); });">Select none</button> 
</p>
<label><input type="checkbox" class="csys" id="cslisp-machines" name="cslisp-machines" checked>LISP machines</label><label><input type="checkbox" class="csys" id="cssmalltalk" name="cssmalltalk" checked>Smalltalk</label><label><input type="checkbox" class="csys" id="csunix" name="csunix" checked>UNIX</label><label><input type="checkbox" class="csys" id="csspreadsheets" name="csspreadsheets" checked>Spreadsheets</label><label><input type="checkbox" class="csys" id="csweb" name="csweb" checked>Web platform</label><label><input type="checkbox" class="csys" id="cshypercard" name="cshypercard" checked>Hypercard</label><label><input type="checkbox" class="csys" id="csboxer" name="csboxer" checked>Boxer</label><label><input type="checkbox" class="csys" id="csnotebooks" name="csnotebooks" checked>Notebooks</label><label><input type="checkbox" class="csys" id="cshaskell" name="cshaskell" checked>Haskell</label>
</div>
<div class="checks">
<p>
<button onclick="[...document.getElementsByClassName('cdim')].forEach(function(e) { e.checked=true; if (e.onchange) e.onchange(); });">Select all</button> 
<button onclick="[...document.getElementsByClassName('cdim')].forEach(function(e) { e.checked=false; if (e.onchange) e.onchange(); });">Select none</button> 
</p>
<label><input type="checkbox" class="cdim" id="cdinteraction" name="cdinteraction" checked>Interaction</label><label><input type="checkbox" class="cdim" id="cdnotation" name="cdnotation" checked>Notation</label><label><input type="checkbox" class="cdim" id="cdconceptual" name="cdconceptual" checked>Conceptual structure</label><label><input type="checkbox" class="cdim" id="cdcustomizability" name="cdcustomizability" checked>Customizability</label><label><input type="checkbox" class="cdim" id="cdcomplexity" name="cdcomplexity" checked>Complexity</label><label><input type="checkbox" class="cdim" id="cderrors" name="cderrors" checked>Errors</label><label><input type="checkbox" class="cdim" id="cdadoptability" name="cdadoptability" checked>Adoptability</label>
</div>
</div>
</section>
<section data-file="index" data-id="systems-intro" data-title="Systems">
<h1>Programming systems</h1>
<embed type="application/transclusion" src="paper,definition" />
<a class="tlink" href="#left=paper,introduction"><i class="fa fa-arrow-right"></i>read more in the paper</a>
</section>
<section data-class="systems frameset" data-file="index" data-id="systems" data-title="Systems">
<embed type="application/transclusion" src="index,systems-intro" />
<embed type="application/transclusion" src="systems/lisp-machines,summary" />
<embed type="application/transclusion" src="systems/smalltalk,summary" />
<embed type="application/transclusion" src="systems/unix,summary" />
<embed type="application/transclusion" src="systems/spreadsheets,summary" />
<embed type="application/transclusion" src="systems/web,summary" />
<embed type="application/transclusion" src="systems/hypercard,summary" />
<embed type="application/transclusion" src="systems/boxer,summary" />
<embed type="application/transclusion" src="systems/notebooks,summary" />
<embed type="application/transclusion" src="systems/haskell,summary" />
</section>
<section data-file="paper" data-id="main" data-title="Paper">
<p>paper....</p>
</section>
<section data-file="paper" data-id="abstract" data-title="Abstract">
<h1>Abstract</h1>
<p>Programming requires much more than just writing code in a programming language. It is usually done in the context of a stateful environment, by interacting with a system through a graphical user interface. Yet, this wide space of possibilities lacks a common structure for navigation. Work on programming systems fails to form a coherent body of research, making it hard to improve on past work and advance the state of the art.</p>
<p>In computer science, much has been said and done to allow comparison of <em>programming languages</em>, yet no similar theory exists for <em>programming systems</em>; we believe that programming systems deserve a theory too.</p>
<p>We present a framework of <em>technical dimensions</em> which capture the underlying characteristics of programming systems and provide a means for conceptualizing and comparing them.</p>
<p>We identify technical dimensions by examining past influential programming systems and reviewing their design principles, technical capabilities, and styles of user interaction. Technical dimensions capture characteristics that may be studied, compared and advanced independently. This makes it possible to talk about programming systems in a way that can be shared and constructively debated rather than relying solely on personal impressions.</p>
<p>Our framework is derived using a qualitative analysis of past programming systems. We outline two concrete ways of using our framework. First, we show how it can analyze a recently developed novel programming system. Then, we use it to identify an interesting unexplored point in the design space of programming systems.</p>
<p>Much research effort focuses on building programming systems that are easier to use, accessible to non-experts, moldable and/or powerful, but such efforts are disconnected. They are informal, guided by the personal vision of their authors and thus are only evaluable and comparable on the basis of individual experience using them. By providing foundations for more systematic research, we can help programming systems researchers to stand, at last, on the shoulders of giants.</p>
</section>
<section data-file="paper" data-id="introduction" data-title="Introduction">
<p>A systematic presentation removes ideas from the ground that made them grow and arranges them in an artificial pattern.
The Tyranny of Science, Paul Feyerabend</p>
<p>Irony is said to allow the artist to continue his creative production while immersed in a sociocultural context of which he is critical.
Irony; or, the Self-Critical Opacity of Postmodernist Architecture, Emmanuel Petit</p>
<h1>Introduction</h1>
<p>Many forms of software have been developed to enable programming. The classic form consists of a <em>programming language</em>, a text editor to enter source code, and a compiler to turn it into an executable program. Instances of this form are differentiated by the syntax and semantics of the language, along with the implementation techniques in the compiler or runtime environment. Since the advent of graphical user interfaces (GUIs), programming languages can be found embedded within graphical environments that increasingly define how programmers work with the language---for instance, by directly supporting debugging or refactoring. Beyond this, the rise of GUIs also permits diverse visual forms of programming, including visual languages and GUI-based end-user programming tools.</p>
<p>This paper advocates a shift of attention from <em>programming languages</em> to the more general notion of "software that enables programming"---in other words, <em>programming systems</em>.</p>
<p>\begin{defn}[Programming System]
A \emph{programming system} is an integrated and complete set of tools sufficient for creating, modifying, and executing programs. These will include notations for structuring programs and data, facilities for running and debugging programs, and interfaces for performing all of these tasks. Facilities for testing, analysis, packaging, or version control may also be present. Notations include programming languages and interfaces include text editors, but are not limited to these.
\end{defn}</p>
<p>This notion covers classic programming languages together with their editors, debuggers, compilers, and other tools. Yet it is intentionally broad enough to accommodate image-based programming environments like Smalltalk, operating systems like UNIX, and hypermedia authoring systems like Hypercard, in addition to various other examples we will mention.</p>
<h2>The problem: no systematic framework for systems</h2>
<p>There is a growing interest in broader forms of <em>programming systems</em>, both in the programming research community and in industry. Researchers are studying topics such as <em>programming experience</em> and <em>live programming</em> that require considering not just the <em>language</em>, but further aspects of a given system. At the same time, commercial companies are building new programming environments like Replit\ \cite{ReplitWeb} or low-code tools like Dark\ \cite{DarkWeb} and Glide\ \cite{GlideWeb}. Yet, such topics remain at the sidelines of mainstream programming research. While <em>programming languages</em> are a well-established concept, analysed and compared in a common vocabulary, no similar foundation exists for the wider range of <em>programming systems</em>.</p>
<p>The academic research on programming suffers from this lack of common vocabulary. While we may thoroughly assess programming <em>languages</em>, as soon as we add interaction or graphics into the picture, evaluation beyond subjective "coolness" becomes fraught with difficulty.^[The same difficulty in the context of user interface systems has been analyzed by Olsen\ \cite{EvUISR}. Interesting future work would be a detailed analysis of publications on programming systems to understand this issue in depth. One notable characteristic is that publications tend to present (parts of) new systems. This is the case for 5/6 and 6/7 papers in the LIVE 2020 and 2021 workshops respectively\ \cite{LIVE20, LIVE21}. In contrast, publications in the field of programming <em>languages</em> often address specific issues of interest to a greater number of languages.] Moreover, when designing new systems, inspiration is often drawn from the same few standalone sources of ideas. These might be influential past systems like Smalltalk, programmable end-user applications like spreadsheets, or motivational illustrations like those of Bret Victor\ \cite{BretVictor}.</p>
<p>Instead of forming a solid body of work, the ideas that emerge are difficult to relate to each other. The research methods used to study programming systems lack the rigorous structure of programming language research methods. They tend to rely on singleton examples, which demonstrate their author's ideas, but are inadequate methods for comparing new ideas with the work of others. This makes it hard to build on top and thereby advance the state of the art.</p>
<p>Studying <em>programming systems</em> is not merely about taking a programming language and looking at the tools that surround it. It presents a <em>paradigm shift</em> to a perspective that is, at least partly, <em>incommensurable</em> with that of languages. When studying programming languages, everything that matters is in the program code; when studying programming systems, everything that matters is in the <em>interaction</em> between the programmer and the system. As documented by Gabriel\ \cite{PLrev}, looking at a <em>system</em> from a <em>language</em> perspective makes it impossible to think about concepts that arise from interaction with a system, but are not reflected in the language. Thus, we must proceed with some caution. As we will see, when we talk about Lisp as a programming system, we mean something very different from a parenthesis-heavy programming language!</p>
<h2>Contributions</h2>
<p>We propose a common language as an initial step towards a more progressive research on programming systems. Our set of <em>technical dimensions</em> seeks to break down the holistic view of systems along various specific "axes". The dimensions identify a range of possible design choices, characterized by two extreme points in the design space. They are not quantitative, but they allow comparison by locating systems on a common axis. We do not intend for the extreme points to represent "good" or "bad" designs; we expect any position to be a result of design trade-offs. At this early stage in the life of such a framework, we encourage agreement on descriptions of systems first in order to settle any normative judgements later.</p>
<p>The set of dimensions can be understood as a map of the design space of programming systems (Figure\ \ref{fig:tech-dims-diagram}). Past and present systems will serve as landmarks, and with enough of them, we may reveal unexplored or overlooked possibilities. So far, the field has not been able to establish a virtuous cycle of feedback; it is hard for practitioners to situate their work in the context of others' so that subsequent work can improve on it. Our aim is to provide foundations for the study of programming systems that would allow such development.</p>
<p>This paper is intended as a reference on the current state of the technical dimensions framework and it is meant to be <em>used</em> rather than <em>read</em>. We present the dimensions in detail, but encourage the reader to skim through the details on the first read. Subsequently, we suggest revisiting dimensions which seem relevant to a concrete system known to the reader. The main contributions of this paper are organized as follows:</p>
<ol>
<li>In Section\ \ref{programming-systems}, we characterize what a programming system is and review landmark programming systems of the past that are used as examples throughout this paper, as well as to delineate our notion of a programming system.</li>
<li>We present the technical dimensions in detail, organised into related clusters: <em>interaction</em>, <em>notation</em>, <em>conceptual structure</em>, <em>customizability</em>, <em>complexity</em>, <em>errors</em>, and <em>adoptability</em>. For each dimension, we give examples that illustrate the range of values along its axis. We intend this as a reference to be used as needed rather than something to be read from start to finish, so we recommend skimming the catalogue on the first reading.</li>
<li>In Section\ \ref{evaluation}, we sketch two ways of using the technical dimensions framework. In Section\ \ref{evaluating-the-dark-programming-system}, we use it to evaluate a recent interesting programming system; in Section\ \ref{exploring-the-design-space}, we use it to identify an unexplored point in the design space and envision a potential novel programming system.</li>
</ol>
<p>\begin{figure}
\centering
\includegraphics[width=0.6\linewidth]{plot-figure0.pdf}
\caption{One 2-dimensional slice of the space of possible systems, to be examined in more detail in Section\ \ref{exploring-the-design-space}.\label{fig:tech-dims-diagram}}
\end{figure}</p>
</section>
<section data-file="paper" data-id="definition" data-title="What is a Programming System?">
<p>A <em>programming system</em> is an integrated and complete set of tools sufficient for creating, modifying, and executing programs. These will include notations for structuring programs and data, facilities for running and debugging programs, and interfaces for performing all of these tasks. Facilities for testing, analysis, packaging, or version control may also be present. Notations include programming languages and interfaces include text editors, but are not limited to these.</p>
</section>
<section data-file="paper" data-id="programming-systems">
<embed type="application/transclusion" src="content=paper;definition,link=paper;programming-systems" />
<p>We introduce the notion of a <em>programming system</em> through a number of example systems. We draw them from three broad reference classes:</p>
<ul>
<li><p>Software ecosystems built around a text-based programming <em>language</em>. They consist of a set of tools such as compilers, debuggers, and profilers. These tools may exist as separate command-line programs, or within an Integrated Development Environment.</p></li>
<li><p>Those that resemble an <em>operating system</em> (OS) in that they structure the execution environment and encompass the resources of an entire machine (physical or virtual). They provide a common interface for communication, both between the user and the computer, and between programs themselves.</p></li>
<li><p>Programmable <em>applications</em>, typically optimized for a specific domain, offering a limited degree of programmability which may be increased with newer versions.</p></li>
</ul>
<p>We will proceed to detail some systems under this grouping. This will provide an intuition for the notion of a programming system and establish a collection of go-to examples for the rest of the paper.</p>
<h2>Systems based around languages</h2>
<p>Text-based programming languages sit within programming systems whose boundaries are not explicitly defined. To speak of a programming system, we need to consider a language with, at minimum, an editor and a compiler or interpreter. However, the exact boundaries are a design choice that significantly affects our analysis.</p>
<p>\paragraph{Java with the Eclipse ecosystem.}
Java\ \cite{Java} cannot be viewed as a programming system on its own, but it is one if we consider it as embedded in an ecosystem of tools. There are multiple ways to delineate this, resulting in different analyses. A minimalistic programming system would consist of a text editor to write Java code and a command line compiler. A more realistic system is Java as embedded in the Eclipse IDE\ \cite{Eclipse}. The programming systems view allows us to see all there is beyond the textual code. In the case of Eclipse, this includes the debugger, refactoring tools, testing and modelling tools, GUI designers, and so on. This delineation yields a programming system that is powerful and convenient, but has a large number of concepts and secondary notations.</p>
<p>\paragraph{Haskell tools ecosystem.}
Haskell is an even more language-focused programming system. It is used through the command-line <em>GHC</em>  compiler\ \cite{GHC} and <em>GHCi</em> REPL, alongside a text editor that provides features like syntax highlighting and auto-completion. Any editor that supports the Language Server Protocol\ \cite{LSP} will suffice to complete the programming system.</p>
<p>Haskell is mathematically rooted and relies on mathematical intuition for understanding many of its concepts. This background is also reflected in the notations it uses. In addition to the concrete language syntax for writing code, the ecosystem also uses an informal mathematical notation for writing about Haskell (e.g. in academic papers or on the whiteboard). This provides an additional tool for manipulating Haskell programs. Experiments on paper can provide a kind of rapid feedback that other systems may provide through live programming.</p>
<p>\paragraph{From REPLs to notebooks.}
A different kind of developer ecosystem that evolved around a programming language is the Jupyter notebook platform\ \cite{Jupyter}. In Jupyter, data scientists write scripts divided into notebook cells, execute them interactively and see the resulting data and visualizations directly in the notebook itself. This brings together the REPL, which dates back to conversational implementations of Lisp in the 1960s, with literate programming\ \cite{LiterateProg} used in the late 1980s in Mathematica 1.0\ \cite{Mathematica}.</p>
<p>As a programming system, Jupyter has a number of interesting characteristics. The primary outcome of programming is the notebook itself, rather than a separate application to be compiled and run. The code lives in a document format, interleaved with other notations. Code is written in small parts that are executed quickly, offering the user more rapid feedback than in conventional programming. A notebook can be seen as a trace of how the result has been obtained, yet one often problematic feature of notebooks is that some allow the user to run code blocks out-of-order. The code manipulates mutable state that exists in a "kernel" running in the background. Thus, retracing one's steps in a notebook is more subtle than in, say, Common Lisp\ \cite{CommonLisp}, where the <code>dribble</code> function would directly record the user's session to a file.</p>
<h2>OS-like programming systems</h2>
<p>"OS-likes" begin from the 1960s when it became possible to interact one-on-one with a computer. First, time-sharing systems enabled interactive shared use of a computer via a teletype; smaller computers such as the PDP-1 and PDP-8 provided similar direct interaction, while 1970s workstations such as the Alto and Lisp Machines added graphical displays and mouse input. These <em>OS-like</em> systems stand out as having the totalising scope of <em>operating systems</em>, whether or not they are ordinarily seen as taking this role.</p>
<p>\paragraph{MacLisp and Interlisp.}
LISP 1.5\ \cite{LISP15} arrived before the rise of interactive computers, but the existence of an interpreter and the absence of declarations made it natural to use Lisp interactively, with the first such implementations appearing in the early 1960s. Two branches of the Lisp family\ \cite{LispEvolve}, MacLisp and the later Interlisp, embraced the interactive "conversational" way of working, first through a teletype and later using the screen and keyboard.</p>
<p>Both MacLisp and Interlisp adopted the idea of <em>persistent address space</em>. Both program code and program state were preserved when powering off the system, and could be accessed and modified interactively as well as programmatically using the <em>same means</em>. Lisp Machines embraced the idea that the machine runs continually and saves the state to disk when needed. Today, this is widely seen in cloud-based services like Google Docs and online IDEs. Another idea pioneered in MacLisp and Interlisp was the use of <em>structure editors</em>. These let programmers work with Lisp data structures not as sequences of characters, but as nested lists. In Interlisp, the programmer would use commands such as <code>*P</code> to print the current expression, or <code>*(2 (X Y))</code> to replace its second element with the argument <code>(X Y)</code>. The PILOT system\ \cite{Pilot} offered even more sophisticated conversational features. For typographical errors and other slips, it would offer an automatic fix for the user to interactively accept, modifying the program in memory and resuming execution.</p>
<p>\paragraph{Smalltalk.}
Smalltalk appeared in the 1970s with a distinct ambition of providing "dynamic media which can be used by human beings of all ages"\ \cite{PersonalDynMedia}. The authors saw computers as <em>meta-media</em> that could become a range of other media for education, discourse, creative arts, simulation and other applications not yet invented. Smalltalk was designed for single-user workstations with a graphical display, and pioneered this display not just for applications but also for programming itself. In Smalltalk 72, one wrote code in the bottom half of the screen using a structure editor controlled by a mouse, and menus to edit definitions. In Smalltalk-76 and later, this had switched to text editing embedded in a <em>class browser</em> for navigating through classes and their methods.</p>
<p>Similarly to Lisp systems, Smalltalk adopts the persistent address space model of programming where all objects remain in memory, but based on <em>objects</em> and <em>message passing</em> rather than <em>lists</em>. Any changes made to the system state by programming or execution are preserved when the computer is turned off. Lastly, the fact that much of the Smalltalk environment is implemented in itself makes it possible to extensively modify the system from within.</p>
<p>We include Lisp and Smalltalk in the OS-likes because they function as operating systems in many ways. On specialized machines, like the Xerox Alto and Lisp machines, the user started their machine directly in the Lisp or Smalltalk environment and was able to do everything they needed from <em>within</em> the system. Nowadays, however, this experience is associated with UNIX and its descendants on a vast range of commodity machines.</p>
<p>\paragraph{UNIX.}
UNIX illustrates the fact that many aspects of programming systems are shaped by their intended target audience. Built for computer hackers\ \cite{Hackers}, its abstractions and interface are close to the machine. Although historically linked to the C language, UNIX developed a language-agnostic set of abstractions that make it possible to use multiple programming languages in a single system. While everything is an object in Smalltalk, the ontology of the UNIX system consists of files, memory, executable programs, and running processes. Note the explicit "stage" distinction here: UNIX distinguishes between volatile <em>memory</em> structures, which are lost when the system is shut down, and non-volatile <em>disk</em> structures that are preserved. This distinction between types of memory is considered, by Lisp and Smalltalk, to be an implementation detail to be abstracted over by their persistent address space. Still, this did not prevent the UNIX ontology from supporting a pluralistic ecosystem of different languages and tools.</p>
<p>\paragraph{Early and modern Web.}
The Web evolved\ \cite{DotCom} from a system for sharing and organizing information to a <em>programming system</em>. Today, it consists of a wide range of server-side programming tools, JavaScript and languages that compile to it, and notations like HTML and CSS. As a programming system, the "modern 2020s web" is reasonably distinct from the "early 1990s web". In the early web, JavaScript code was distributed in a form that made it easy to copy and re-use existing scripts, which led to enthusiastic adoption by non-experts---recalling the birth of microcomputers like Commodore 64 with BASIC a decade earlier.</p>
<p>In the "modern web", multiple programming languages treat JavaScript as a compilation target, and JavaScript is also used as a language on the server-side. This web is no longer simple enough to encourage copy-and-paste remixing of code from different sites. However, it does come with advanced developer tools that provide functionality resembling early interactive programming systems like Lisp and Smalltalk. The <em>Document Object Model (DOM)</em> structure created by a web page is transparent, accessible to the user and modifiable through the built-in browser inspector tools. Third-party code to modify the DOM can be injected via extensions. The DOM almost resembles the tree/graph model of Smalltalk and Lisp images, lacking the key persistence property. This limitation, however, is being addressed by Webstrates\ \cite{Webstrates}.</p>
<h2>Application-focused systems</h2>
<p>The previously discussed programming systems were either universal, not focusing on any particular kind of application, or targeted at broad fields, such as Artificial Intelligence and symbolic data manipulation in Lisp's case. In contrast, the following examples focus on more narrow kinds of applications that need to be built. Many support programming based on rich interactions with specialized visual and textual notations.</p>
<p>\paragraph{Spreadsheets.}
The first spreadsheets became available in 1979 in VisiCalc\ \cite{VisiCalc, VisiCalc2} and helped analysts perform budget calculations. As programming systems, spreadsheets are notable for their programming substrate (a two-dimensional grid) and evaluation model (automatic re-evaluation). The programmability of spreadsheets developed over time, acquiring features that made them into powerful programming systems in a way VisiCalc was not. The final step was the 1993 inclusion of <em>macros</em> in Excel, later further extended with <em>Visual Basic for Applications</em>.</p>
<p>\paragraph{Graphical "languages".}
Efforts to support programming without relying on textual code can only be called "languages" in a metaphorical sense. In these programming systems, programs are made out of graphical structures as in LabView\ \cite{LabView} or Programming-By-Example\ \cite{PBE}.</p>
<p>\paragraph{HyperCard.}
While spreadsheets were designed to solve problems in a specific application area, HyperCard\ \cite{HyperCard} was designed around a particular application format. Programs are "stacks of cards" containing multimedia components and controls such as buttons. These controls can be programmed with pre-defined operations like "navigate to another card", or via the HyperTalk scripting language for anything more sophisticated.</p>
<p>As a programming system, HyperCard is interesting for a couple of reasons. It effectively combines visual and textual notation. Programs appear the same way during editing as they do during execution. Most notably, HyperCard supports gradual progression from the "user" role to "developer": a user may first use stacks, then go on to edit the visual aspects or choose pre-defined logic until, eventually, they learn to program in HyperTalk.</p>
</section>
<section data-file="dimensions/interaction" data-id="summary" data-title="Interaction">
<h1><i class="fa fa-cog"></i> Interaction <a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/interaction,index"><i class="fa fa-arrow-right"></i>Description and relations...</a></h1>
<p>How do users manifest their ideas, evaluate the result, and generate new ideas in response?</p>
<h2>Dimensions</h2>
<ul>
<li>
What are the gulfs of execution and evaluation and how are they related?<br />
<a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/interaction,feedback-loops!"><i class="fa fa-arrow-right"></i>!</a>
</li>
<li>
Which sets of feedback loops only occur together?<br />
<a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/interaction,modes-of-interaction!"><i class="fa fa-arrow-right"></i>!</a>
</li>
<li>
How do we go from abstractions to concrete examples and vice versa?<br />
<a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/interaction,abstraction-construction!"><i class="fa fa-arrow-right"></i>!</a>
</li>
</ul>
<h2>Examples</h2>
<ul>
<li><a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/interaction,immediate-feedback!"><i class="fa fa-arrow-right"></i>!</a></li>
<li><a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/interaction,direct-manipulation!"><i class="fa fa-arrow-right"></i>!</a></li>
</ul>
</section>
<section data-file="dimensions/interaction" data-id="index" data-summary="How do users manifest their ideas, evaluate the result, and generate new ideas in response?" data-title="Interaction">
<h2>Interaction</h2>
<p>An essential aspect of programming systems is how the user interacts with them when creating programs. Take the standard form of statically typed, compiled languages with straightforward library linking: here, programmers write their code in a text editor, invoke the compiler, and read through error messages they get. After fixing the code to pass compilation, a similar process might happen with runtime errors.</p>
<p>Other forms are yet possible. On the one hand, some typical interactions like compilation or execution of a program  may not be perceptible at all. On the other hand, the system may provide various interfaces to support the plethora of other interactions that are often important in programming, such as looking up documentation, managing dependencies, refactoring or pair programming.</p>
<p>We focus on the interactions where programmer interacts with the system to construct a program with a desired behavior. To analyze those, we use the concepts of <em>gulf of execution</em> and <em>gulf of evaluation</em> from <em>The Design of Everyday Things</em>\ \cite{Norman}.</p>
<embed type="application/transclusion" src="content=summary,link=feedback-loops" />
<h3>Relations</h3>
<ul>
<li><em>Errors</em> (Section \ref{errors}) A longer evaluation gulf delays the detection of errors. A longer execution gulf can increase the <em>likelihood</em> of errors (e.g. writing a lot of code or taking a long time to write it). By turning runtime bugs into statically detected bugs, the combined evaluation gulfs can be reduced.</li>
<li><em>Adoptability</em> (Section \ref{adoptability}): The <em>execution</em> gulf is concerned with software using and programming in general. The time taken to realize an idea in software is affected by the user's familiarity and the system's <em>learnability</em>.</li>
<li><em>Notation</em> (Section \ref{notation}): Feedback loops are related to <em>notational structures</em>. In a system with multiple notations, each notation may have different associated feedback loops. The motto "The thing on the screen is supposed to be the actual thing" \cite{NakedObjects}, adopted in the context of live programming, relates <em>liveness</em> to a direct connection between surface and internal notations. The idea is that interactable objects should be equipped with faithful behavior, instead of being intangible shadows cast by the hidden <em>real</em> object.</li>
</ul>
</section>
<section data-file="dimensions/interaction" data-id="feedback-loops" data-title="Dimension: Feedback loops">
<h3>Dimension: feedback loops</h3>
<p>In using a system, one first has some idea and attempts to make it exist in the software; the gap between the user's goal and the means to execute the goal is known as the <em>gulf of execution</em>. Then, one compares the result actually achieved to the original goal in mind; this crosses the <em>gulf of evaluation</em>. These two activities comprise the <em>feedback loop</em> through which a user gradually realises their desires in the imagination, or refines those desires to find out "what they actually want".</p>
<p>A system must contain at least one such feedback loop, but may contain several at different levels or specialized to certain domains. For each of them, we can separate the gulf of execution and evaluation as independent legs of the journey, with possibly different manners and speeds of crossing them.</p>
<p>\begin{figure}
\centering
\includegraphics[width=0.5\linewidth]{feedback-loops.png}
\caption{The nested feedback loops of a statically-checked programming language.\label{fig:feedback-loops}}
\end{figure}</p>
<p>For example, we can analyze statically checked <em>programming languages</em> (e.g. Java, Haskell) into several feedback loops (Figure \ref{fig:feedback-loops}):</p>
<ol>
<li><p>Programmers often think about design details and calculations on a whiteboard or notebook, even before writing code. This <em>supplementary medium</em> has its own feedback loop, even though this is often not automatic.</p></li>
<li>
<p>The code is written and is then put through the static checker. An error sends the user back to writing code. In the case of success, they are "allowed" to run the program, leading into cycle 3.</p>
<ul>
<li>The execution gulf comprises multiple cycles of the supplementary medium, plus whatever overhead is needed to invoke the compiler (such as build systems).</li>
<li>The evaluation gulf is essentially the waiting period before static errors or a successful termination are observed. Hence this is bounded by some function of the length of the code (the same cannot be said for the following cycle 3.)</li>
</ul>
</li>
<li>
<p>With a runnable program, the user now evaluates the <em>runtime</em> behavior. Runtime errors can send the user back to writing code to be checked, or to tweak dynamically loaded data files in a similar cycle.</p>
<ul>
<li>The execution gulf here may include multiple iterations of cycle 2, each with its own nested cycle 1.</li>
<li><p>The <em>evaluation</em> gulf here is theoretically unbounded; one may have to wait a very long time, or create very specific conditions, to rule out certain bugs (like race conditions) or simply to consider the program as fit for purpose.</p></li>
<li><p>By imposing <em>static checks</em>, some bugs can be pushed earlier to the evaluation stage of cycle 2, reducing the likely size of the cycle 3 <em>evaluation</em> gulf.</p></li>
<li><p>On the other hand, this can make it harder to write statically valid code, which may increase the number of level-2 cycles, thus increasing the total <em>execution</em> gulf at level 3.</p></li>
<li>Depending on how these balance out, the total top-level feedback loop may grow longer or shorter.</li>
</ul>
</li>
</ol>
</section>
<section data-file="dimensions/interaction" data-id="immediate-feedback" data-title="Example: Immediate feedback">
<h3>Example: immediate feedback</h3>
<p>The specific case where the <em>evaluation</em> gulf is minimized to be imperceptible is known as <em>immediate feedback</em>. Once the user has caused some change to the system, its effects (including errors) are immediately visible. This is a key ingredient of <em>liveness</em>, though it is not sufficient on its own. (See <em>Relations</em>)</p>
<p>The ease of achieving immediate feedback is obviously constrained by the computational load of the user's effects on the system, and the system's performance on such tasks. However, such "loading time" is not the only way feedback can be delayed: a common situation is where the user has to manually ask for (or "poll") the relevant state of the system after their actions, even if the system finished the task quickly. Here, the feedback could be described as <em>immediate upon demand</em> yet not <em>automatically demanded</em>. For convenience, we choose to include the latter criterion---automatic demand of result---in our definition of immediate feedback.</p>
<p>In a <em>REPL</em> or <em>shell</em>, there is a <em>main</em> cycle of typing commands and seeing their output, and a <em>secondary</em> cycle of typing and checking the command line itself. The output of commands can be immediate, but usually reflects only part of the total effects or even none at all. The user must manually issue further commands afterwards, to check the relevant state bit by bit. The secondary cycle, like all typing, provides immediate feedback in the form of character "echo", but things like syntax errors generally only get reported <em>after</em> the entire line is submitted. This evaluation gulf has been reduced in the JavaScript console of web browsers, where the line is "run" in a limited manner on every keystroke. Simple commands without side-effects,^[Of course, these are detected via some conservative over-approximation which excludes expressions that <em>might</em> side-effect.] such as calls to pure functions, can give instantly previewed results---though partially typed expressions and syntax errors will not trigger previews.</p>
</section>
<section data-file="dimensions/interaction" data-id="direct-manipulation" data-title="Example: Direct manipulation">
<h3>Example: direct manipulation</h3>
<p>Direct manipulation \cite{DirectManip} is a special case of an immediate feedback loop. The user sees and interacts with an artefact in a way that is as similar as possible to real life; this typically includes dragging with a cursor or finger in order to physically move a visual item, and is limited by the particular haptic technology in use.</p>
<p>Naturally, because moving real things with one's hands does not involve any waiting for the object to "catch up",^[In some situations, such as steering a boat with a rudder, there is a delay between input and effect. But on closer inspection, this delay is between the rudder and the boat; we do not see the hand pass through the wheel like a hologram, followed by the wheel turning a second later. In real life, objects touched directly give immediate feedback; objects controlled further down the line might not!] direct manipulation is necessarily an immediate-feedback cycle. If, on the other hand, one were to move a figure on screen by typing new co-ordinates in a text box, then this could still give <em>immediate feedback</em> (if the update appears instant and automatic) but would <em>not</em> be an example of direct manipulation.</p>
<p><em>Spreadsheets</em> contain a feedback loop for direct manipulation of values and formatting, as in any other WYSIWYG application. Here, there is feedback for every character typed and every change of style. This is not the case in the other loop for formula editing and formula invocation. There, we see a larger execution gulf for designing and typing formulas, where feedback is only given upon committing the formula by pressing enter. This makes it an "immediate feedback" loop only <em>on-demand</em>, as defined above.</p>
</section>
<section data-file="dimensions/interaction" data-id="modes-of-interaction" data-title="Dimension: Modes of interaction">
<h3>Dimension: modes of interaction</h3>
<p>The possible interactions in a programming system are typically structured so that interactions, and the associated feedback loops, are only available in certain <em>modes</em>. For example, when creating a new project, the user may be able to configure the project through a conversational interface like <code>npm init</code> in modern JavaScript. Such interactions are no longer available once the project is created. This idea of interaction modes goes beyond just programming systems, appearing in software engineering methodologies. In particular, having a separate <em>implementation</em> and <em>maintenance</em> phase would be an example of two modes.</p>
<p><em>Editing vs debugging.</em> A good example is the distinction between <em>editing</em> and <em>debugging</em> mode. When debugging a program, the user can modify the program state and get (more) immediate feedback on what individual operations do. In some systems, one can even modify the program itself during debugging. Such feedback loops are not available outside of debugging mode.</p>
<p><em>Lisp systems</em> sometimes distinguish between <em>interpreted</em> and <em>compiled</em> mode. The two modes do not differ just in the efficiency of code execution, but also in the interactions they enable. In the interpreted mode, code can be tested interactively and errors may be corrected during the code execution (see <em>Error response</em>). In the compiled mode, the program can only be tested as a whole. The same two modes also exist, for example, in some Haskell systems where the REPL uses an interpreter (GHCi) distinct from the compiler (GHC).</p>
<p><em>Jupyter notebooks.</em> A programming system may also unify modes that are typically distinct. The Jupyter notebook environment does not have a distinct debugging mode; the user runs blocks of code and receives the result. The single mode can be used to quickly try things out, and to generate the final result, partly playing the role of both debugging and editing modes. However, even Jupyter notebooks distinguish between editing a document and running code.</p>
</section>
<section data-file="dimensions/interaction" data-id="abstraction-construction" data-title="Dimension: Abstraction construction">
<h3>Dimension: abstraction construction</h3>
<p>A necessary activity in programming is going between abstract schemas and concrete instances. Abstractions can be constructed from concrete examples, first principles or through other methods. A part of the process may happen in the programmer's mind: they think of concrete cases and come up with an abstract concept, which they then directly encode in the system. Alternatively, a system can support these different methods directly.</p>
<p>One option is to construct abstractions <em>from first principles</em>. Here, the programmer starts by defining an abstract entity such as an interface in object-oriented programming languages. To do this, they have to think what the required abstraction will be (in the mind) and then encode it (in the system).</p>
<p>Another option is to construct abstractions <em>from concrete cases</em>. Here, the programmer uses the system to solve one or more concrete problems and, when they are satisfied, the system guides them in creating an abstraction based on their concrete case(s). In a programming language IDE this manifests as the "extract function" refactor, whereas in other systems we see approaches like macro recording.</p>
<p><em>Pygmalion.</em> In Pygmalion \cite{Pygmalion}, all programming is done by manipulating concrete icons that represent concrete things. To create an abstraction, you can use "Remember mode", which records the operations done on icons and makes it possible to bind this recording to a new icon.</p>
<p><em>Jupyter notebook.</em> In Jupyter notebooks, you are inclined to work with concrete things, because you see previews after individual cells. This discourages creating abstractions, because then you would not be able to look inside at such a fine grained level.</p>
<p><em>Spreadsheets.</em> Up until the recent introduction of lambda expressions into Excel, spreadsheets have been relentlessly concrete, without any way to abstract and reuse patterns of computation other than copy-and-paste.</p>
</section>
<section data-class="dimensions-notation-anchor" data-file="dimensions/notation" data-id="summary" data-title="Notation">
<h1><i class="fa fa-code"></i> Notation <a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,index"><i class="fa fa-arrow-right"></i>Description and relations...</a></h1>
<p>How are the different textual and visual programming notations related?</p>
<h2>Dimensions</h2>
<ul>
<li>
What notations are used to program the system and how are they related?<br />
<a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,notational-structure!"><i class="fa fa-arrow-right"></i>!</a>
</li>
<li>
What is the connection between what a user sees and what a computer program sees?<br />
<a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,surface-internal-notation!"><i class="fa fa-arrow-right"></i>!</a>
</li>
<li>
Is one notation more important than others?<br />
<a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,primary-secondary-notations!"><i class="fa fa-arrow-right"></i>!</a>
</li>
<li>
Do similar expressions encode similar programs?<br />
<a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,expression-geography!"><i class="fa fa-arrow-right"></i>!</a>
</li>
<li>
Does the notation use a small or a large number of basic concepts?<br />
<a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,uniformity-of-notations!"><i class="fa fa-arrow-right"></i>!</a>
</li>
</ul>
<h2>Examples</h2>
<ul>
<li><a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,overlapping-notations!"><i class="fa fa-arrow-right"></i>!</a></li>
<li><a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,complementing-notations!"><i class="fa fa-arrow-right"></i>!</a></li>
<li><a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,explicit-implicit-structure!"><i class="fa fa-arrow-right"></i>!</a></li>
<li><a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,one-string-in-memory!"><i class="fa fa-arrow-right"></i>!</a></li>
<li><a class="tlink" href="#top=.;left=.;footer=.;right=dimensions/notation,two-strings-in-memory!"><i class="fa fa-arrow-right"></i>!</a></li>
</ul>
</section>
<section data-file="dimensions/notation" data-id="index" data-title="xx">
<h2>Notation</h2>
<p>\mybox{How are the different textual / visual programming notations related?}</p>
<p>Programming is always done through some form of notation. We consider notations in the most general sense and include any structured gesture using textual or visual notation. Textual notations primarily include  programming languages, but also things like configuration files. Visual notations include graphical programming languages. Other kinds of structured gestures include user interfaces for constructing visual elements used in the system.</p>
<h3>References</h3>
<p><em>Cognitive Dimensions of Notation</em> \cite{CogDims} provide a comprehensive framework for analysing individual notations, while our focus here is on how multiple notations are related and how they are structured. It is worth noting that the Cognitive Dimensions also define <em>secondary notation</em>, but in a different sense to ours. For them, secondary notation refers to whether a notation allows including redundant information such as color or comments for readability purposes.</p>
<p>The importance of notations in the practice of science, more generally, has been studied by \cite{PaperTools} as "paper tools". These are formula-like entities which can be manipulated by humans in lieu of experimentation, such as the aforementioned mathematical notation in Haskell: a "paper tool" for experimentation on a whiteboard. Programming notations are similar, but they are a way of communicating with a machine; the experimentation does not happen on paper alone.</p>
<h3>Relations</h3>
<ul>
<li><em>Interaction</em> (Section \ref{interaction}): The feedback loops that exist in a programming system are typically associated with individual notations. Different notations may also have different feedback loops.</li>
<li><em>Adoptability</em> (Section \ref{adoptability}): Notational structure can affect learnability. In particular, complementing notations may require (possibly different) users to master multiple notations. Overlapping notations may improve learnability by allowing the user to edit the program in one way (perhaps visually) and see the effect in the other notation (such as code.)</li>
<li><em>Errors</em> (Section \ref{errors}). A process that merely records user actions in a sequence (such as text editing) will, in particular, record any <em>errors</em> the user makes and defer their handling to later use of the data, keeping the errors <em>latent</em>. A process which instead treats user actions as edits to a structure, with constraints and correctness rules, will be able to catch errors at the moment they are introduced and ensure the data coming out is error-free.</li>
</ul>
</section>
<section data-file="dimensions/notation" data-id="notational-structure" data-title="Dimension: Notational structure">
<h3>Dimension: notational structure</h3>
<p>In practice, most programming systems use multiple notations. Different notations can play different roles in the system. On the one hand, multiple <em>overlapping notations</em> can be provided as different ways of programming the same aspects of the system. In this case, each notation may be more suitable to different kinds of users, but may have certain limitations (for example, a visual notation may have a limited expressive power). On the other hand, multiple <em>complementing notations</em> may be used as the means for programming different aspects of the system. In this case, programming the system requires using multiple notations, but each notation may be more suitable for the task at hand; think of how HTML describes document structure while JavaScript specifies its behavior.</p>
</section>
<section data-file="dimensions/notation" data-id="overlapping-notations" data-title="Example: Overlapping notations">
<h3>Example: overlapping notations</h3>
<p>A programming system may provide multiple notations for programming the same aspect of the system. This is typically motivated by an attempt to offer easy ways of completing different tasks: say, a textual notation for defining abstractions and a visual notation for specifying concrete structures. The crucial issue in this kind of arrangement is <em>synchronizing</em> the different notations; if they have different characteristics, this may not be a straightforward mapping. For example, source code may allow more elaborate abstraction mechanisms like  loops, which will appear as visible repetition in the visual notation. What should such a system do when the user edits a single object that resulted from such repetition? Similarly, textual notation may allow incomplete expressions that do not have an equivalent in the visual notation. For programming systems that use <em>overlapping notations</em>, we need to describe how the notations are synchronized.</p>
<p><em>Sketch-n-Sketch</em> \cite{SnS} employs overlapping notations for creating and editing SVG and HTML documents. The user edits documents in an interface with a split-screen structure that shows source code on the left and displayed visual output on the right. They can edit both of these and changes are propagated to the other view. The code can use abstraction mechanisms (such as functions) which are not completely visible in the visual editor (an issue we return to in <em>expression geography</em> below). Sketch-n-Sketch can be seen as an example of a <em>projectional editor</em>.^[Technically, traditional projectional editors usually work more directly with the abstract syntax tree of a programming language.\note{TODO: Insert some more references to research on "projectional editors"}]</p>
<p><em>UML Round-tripping.</em> Another example of a programming system that utilizes the <em>overlapping notations</em> structure are UML design tools that display the program both as source code and as a UML diagram. Edits in one result in automatic update of the other. An example is the Together/J^[<a href="https://www.mindprod.com/jgloss/togetherj.html">https://www.mindprod.com/jgloss/togetherj.html</a>] system. To solve the issue of notation synchronization, such systems often need to store additional information in the textual notation, typically using a special kind of code comment. In this example, after the user re-arranges classes in UML diagrams, the new locations need to be updated in the code.</p>
</section>
<section data-file="dimensions/notation" data-id="complementing-notations" data-title="Example: Complementing notations">
<h3>Example: complementing notations</h3>
<p>A programming system may also provide multiple complementing notations for programming different aspects of its world. Again, this is typically  motivated by the aim to make specifying certain aspects of programming easier, but it is more suitable when the different aspects can be more clearly separated. The key issue for systems with complementing notations is how the different notations are connected. The user may need to use both notations at the same time, or they may need to progress from one to the next level when solving increasingly complex problems. In the latter case, the learnability of progressing from one level to the next is a major concern.</p>
<p><em>Spreadsheets and HyperCard.</em> In Excel, there are three different complementing notations that allow users to specify aspects of increasing complexity: (i) the visual grid, (ii) formula language and (iii) a macro language such as Visual Basic for Applications. The notations are largely independent and have different degrees of expressive power. Entering values in a grid cannot be used for specifying new computations, but it can be used to adapt or run a computation, for example when entering different alternatives in What-If Scenario Analysis. More complex tasks can be achieved using formulas and macros. A user gradually learns more advanced notations, but experience with a previous notation does not help with mastering the next one. The approach optimizes for easy learnability at one level, but introduces a hurdle for users to surmount in order to get to the second level. The notational structure of <em>HyperCard</em> is similar and consists of (i) visual design of cards, (ii) visual programming (via the GUI) with a limited number of operations and (iii) HyperTalk for arbitrary scripting.</p>
<p><em>Boxer and Jupyter.</em> Boxer \cite{Boxer} uses <em>complementing notations</em> in that it combines a visual notation (the layout of the document and the boxes of which it consists) with textual notation (the code in the boxes). Here, the textual notation is always nested within the visual. The case of Jupyter notebooks is similar. The document structure is graphical; code and visual outputs are nested as editable cells in the document. This arrangement is common in many other systems such as Flash or Visual Basic, which both combine visual notation with textual code, although one is not nested in the other.</p>
</section>
<section data-file="dimensions/notation" data-id="surface-internal-notation" data-title="Dimension: Surface and internal notation">
<h3>Dimensions: surface notation and internal notation</h3>
<p>All programming systems build up structures in memory, which we can consider as an <em>internal notation</em> not usually visible to the user. Even though such structures might be revealed in a debugger, they are hidden during normal operation. What the user interacts with instead is the <em>surface notation</em>, typically one of text or shapes on a screen. Every interaction with the surface notation alters the internal notation in some way, and the nature of this connection is worth examining in more detail. To do this, we illustrate with a simplified binary choice for the form of these notations.</p>
</section>
<section data-file="dimensions/notation" data-id="explicit-implicit-structure" data-title="Example: Explicit versus implicit structure">
<h3>Examples: implicit vs. explicit structure</h3>
<p>Let us partition notations into two families. Notations with <em>implicit structure</em> present as a sequence of items, such as textual characters or audio signal amplitudes. Those with <em>explicit structure</em> present as a tree or graph without an obvious order, such as shapes in a vector graphics editor. These two types of notations can be transformed into each other: the implicit structure contained in a string can be <em>parsed</em> into an explicit syntax tree, and an explicit document structure might be <em>rendered</em> into a sequence of characters with the same implicit structure.</p>
<p>Now consider an interface to enter a personal name made up of a forename and a surname. For the surface notation, there could be a single text field to hold the names separated with a space; here, the sub-structure is implicit in the string. Alternatively, there could be two fields where the names are entered separately, and their separation is explicit. A similar choice exists for the internal notation built up in memory: is it a single string, or two separate strings?</p>
<p>We can see that these choices give four combinations. More interestingly, they exhibit unique characters owing to two key asymmetries. Firstly, surface notation is mostly used by humans, while the internal notation is mostly used by the computer. Secondly, and most significantly, computer programs can only work with explicit structure, while humans can understand both explicit and implicit structure. \joel{informal vs formal structure?} Because of the practical consequences of this asymmetry, we will examine the combinations with emphasis on the <em>internal</em> notation first.</p>
</section>
<section data-file="dimensions/notation" data-id="one-string-in-memory" data-title="Examples: One string in memory">
<h3>Examples: one string in memory (implicitly structured internal notation)</h3>
<p>The simplest case here would be with implicit structure in the surface notation, i.e. a single text box for the full name. Edits to the surface are straightforwardly mirrored interally and persisted to disk. This corresponds to <em>text editing</em>. We can generalize this to an idea of <em>sequence editing</em> if we view the fundamental act as <em>recording</em> events to a list over time. For text, these are key presses; for an audio editing interface they would be samples of sound amplitude.</p>
<p>In the other case, with two text boxes, we have <em>sequence rendering</em>. The information about the separation of the two strings, present in the interface, is not quite "thrown away" but is made <em>implicit</em> as a space character in the string. This combination corresponds to Visual Basic generating code from GUI forms, video editors combining multiple clips and effects into a single stream, and 3D renderers turning scene graphs into pixels. Another example is line-based diff tools, which provide side-by-side views and related interfaces, yet must ultimately forward the user's changes to the underlying text file.</p>
<p>Critically, in both of these cases, a computer program can only manipulate the stored sequences <em>as</em> sequences; that is, by inserting, removing, or serially reading. The appealing feature here is that these operations are simple to implement and may be re-usable across many types of sequences. However, any further structure is implicit and, to work with it programmatically, a user must write a program to <em>parse</em> it into something explicit. Furthermore, errors introduced at this stage may simply be <em>recorded</em> into the sequence, only to be discovered much later in an attempt to use the data.</p>
</section>
<section data-file="dimensions/notation" data-id="two-strings-in-memory" data-title="Examples: Two strings in memory">
<h3>Examples: two strings in memory (explicitly structured internal notation)</h3>
<p>\joel{TODO: cite The Many Forms of a Single Fact}
With two text boxes, both notations match, so there is not much work to do. As with sequence editing, edits on the surface can be mirrored to the internal notation. This corresponds to vector graphics editors and 3D modelling tools, as well as <em>structure editors</em> for programming languages. For this reason we call this combination <em>structure editing</em>.</p>
<p>With a single text field, we have <em>structure recovery.</em> Parsing needs to happen each time the input changes. This style is found in the DOM inspector in browser developer tools, where HTML can be edited as text to make changes to the document tree structure. More generally, this is the mode found in compilers and interpreters which accept program source text yet internally work on tree and graph structures. It is also possible to do a sort of structure editing this way, where the experience is made to resemble text editing but the output is explicitly structured.</p>
<p>In both of these cases, in order to write programs to transform, analyze, or otherwise work with the digital artefact the user has created, one can trivially navigate the stored structure instead of parsing it for every use. Parsing is either done away with altogether or is reduced to a transient process that happens during editing; this means errors can be caught at the moment they are introduced instead of remaining latent.</p>
</section>
<section data-file="dimensions/notation" data-id="primary-secondary-notations" data-title="Dimension: Primary and secondary notations">
<h3>Dimension: primary and secondary notations</h3>
<p>In practice, most programming systems use multiple notations. Even in systems based on traditional programming languages, the <em>primary notation</em> of the language is often supported by <em>secondary notations</em> such as annotations encoded in comments and build tool configuration files. However, it is possible for multiple notations to be primary, especially if they are <em>overlapping</em> as defined earlier.</p>
<p><em>Programming languages.</em> Programming systems built around traditional programming languages typically have further notations or structured gestures associated with them. The primary notation in UNIX is the C programming language. Yet this is enclosed in a programming <em>system</em> providing a multi-step mechanism for running C code via the terminal, assisted by secondary notations such as shell scripts. Some programming systems attempt to integrate tools that normally rely on secondary notations into the system itself, reducing the number of secondary notations that the programmer needs to master. For example, in the Smalltalk descendant Pharo, versioning and package management is done from within Pharo, removing the need for secondary notation such as <code>git</code> commands and dependency configuration files.^[The tool for versioning and package management in Pharo can still be seen as an <em>internal</em> domain-specific language and thus as a secondary notation, but its basic structure is <em>shared</em> with other notations in the Pharo system.]</p>
<p><em>Haskell.</em> In Haskell, the primary notation is the programming language, but there are also a number of secondary notations. Those include package managers (e.g. the <code>cabal.project</code> file) or configuration files for Haskell build tools. More interestingly, there is also an informal mathematical notation associated with Haskell that is used when programmers discuss programs on a whiteboard or in academic publications. The idea of having such a mathematical notation dates back to the <em>Report on Algol 58</em> \cite{Alg58}, which explicitly defined a "publication language" for "stating and communicating problems" using Greek letters and subscripts.</p>
</section>
<section data-file="dimensions/notation" data-id="expression-geography" data-title="Dimension: Expression geography">
<h3>Dimension: expression geography</h3>
<p>A crucial feature of a notation is the relationship between the structure of the notation and the structure of the behavior it encodes. Most importantly, do <em>similar expressions</em> in a particular notation represent <em>similar behavior</em>?^[See Basman's \cite{NotYetCraft} similar discussion of "density".] Visual notations may provide a more or less direct mapping. On the one hand, similar-looking code in a block language may mean very different things. On the other hand, similar looking design of two HyperCard cards will result in similar looking cards---the mapping between the notation and the logic is much more direct.</p>
<p><em>C/C++ expression language.</em> In textual notations, this may easily not be the case. Consider the two C conditionals:</p>
<ul>
<li><code>if (x==1) { ... }</code> evaluates the Boolean expression <code>x==1</code> to determine whether <code>x</code> equals <code>1</code>, running the code block if the condition holds.</li>
<li><code>if (x=1) { ... }</code> <em>assigns</em> <code>1</code> to the variable <code>x</code>. In C, assignment is an expression <em>returning</em> the assigned value, so the result <code>1</code> is interpreted as <code>true</code> and the block of code is <em>always</em> executed.</li>
</ul>
<p>A notation can be designed to map better to the logic behind it, for example, by requiring the user to write <code>1==x</code>. This solves the above problem as <code>1</code> is a literal rather than a variable, so it cannot be assigned to (<code>1=x</code> is a compile error).</p>
</section>
<section data-file="dimensions/notation" data-id="uniformity-of-notations" data-title="Dimension: Uniformity of notations">
<h3>Dimension: uniformity of notations</h3>
<p>One common concern with notations is the extent to which they are uniform. A uniform notation can express a wide range of things using just a small number of concepts. The primary example here is S-expressions from Lisp. An S-expression is either an atom or a pair of S-expressions written <code>(s1 . s2)</code>. By convention, an S-expression <code>(s1 . (s2 . (s3 . nil)))</code> represents a list, written as <code>(s1 s2 s3)</code>. In Lisp, uniformity of notations is closely linked to uniformity of representation.^[Notations generally are closely linked to representation in that the notation may mirror the structures used for program representation. Basman et al. \cite{Externalize} refer to this as a distinction between "dead" notation and "live" representation forms).] In the idealized model of LISP 1.5, the data structures represented by an S-expression are what exists in memory. In real-world Lisp systems, the representation in memory is more complex. A programming system can also take a very different approach and fully separate the notation from the in-memory representation.</p>
<p><em>Lisp systems.</em> In Lisp, source code is represented in memory as S-expressions, which can be manipulated by Lisp primitives. In addition, Lisp systems have robust macro processing as part of their semantics: expanding a macro revises the list structure of the code that uses the macro. Combining these makes it possible to define extensions to the system in Lisp, with syntax indistinguishable from Lisp. Moreover, it is possible to write a program that constructs another Lisp program and not only run it interpretively (using the \texttt{eval} function) but compile it at runtime (using the \texttt{compile} function) and execute it. Many domain-specific languages, as well as prototypes of new programming languages (such as Scheme), were implemented this way. Lisp the language is, in this sense, a "programmable programming language". \cite{LispIntro,ProgProgLang}</p>
</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-dm, interaction-open, interaction-principles, interaction-concrete" data-file="systems/boxer" data-id="dims-interaction" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-caret-right' title='single mode of interaction'></i><i class='fa fa-circle-play' title='REPL-like execution'></i><i class='fa fa-hand-pointer' title='some kind of direct manipulation'></i><i class='fa fa-lock-open' title='open abstractions'></i><i class='fa fa-subscript' title='abstraction from first principles'></i><i class='fa fa-eye' title='abstraction from concrete'></i></div>">
<p>Direct manipulation for graphical elements with REPL-like code execution.
Abstraction via messages sent to boxes and using ports to reuse concrete boxes.</p>
</section>
<section data-characteristics="notations-complementing, notations, notations-uniform, notations-graphical" data-file="systems/boxer" data-id="dims-notation" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-handshake' title='has complementing notation'></i><i class='fa fa-arrow-pointer' title='some structure editing'></i><i class='fa fa-bars' title='uniform notation'></i><i class='fa fa-image' title='some graphical notation'></i></div>">
<p>Complementing graphical notation (boxes) with source code in LISP.
Everything is a box (graphical) or a list (code). Tree-based document model.</p>
</section>
<section data-characteristics="concepts-minimal, concepts-domain, concepts-noncomposable" data-file="systems/boxer" data-id="dims-conceptual" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-gem' title='small number of concepts'></i><i class='fa fa-flask' title='domain specific concepts'></i><i class='fa fa-link-slash' title='lacks composability'></i></div>">
<p>Limited number of domain-specific concepts (box, graphical output).
Composability at code level, but not at a higher level (only via ports).</p>
</section>
<section data-characteristics="custom-closed, concepts-large" data-file="systems/boxer" data-id="dims-customizability" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-square-xmark' title='not modifieable at all'></i><i class='fa fa-file' title='large concepts'></i></div>">
<p>Image-based system, editable during execution, but system itself cannot be modified.
Adding only appends boxes and cannot modify existing ones.</p>
</section>
<section data-characteristics="complexity-gc, complexity-domain, complexity-externalized" data-file="systems/boxer" data-id="dims-complexity" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-recycle' title='basic language automation like GC'></i><i class='fa fa-receipt' title='domain-specific factoring (grid, ui, boxes)'></i><i class='fa fa-satellite-dish' title='lots of externalized complexity'></i></div>">
<p>Basic factoring via language and box abstractions (ports). System automates user-interface
handling; high-level language and DSLs offer basic automation (garbage collection, turtle graphics).</p>
</section>
<section data-characteristics="errors-dynamic, errors-immediate" data-file="systems/boxer" data-id="dims-errors" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-person-running' title='runtime error checking'></i><i class='fa fa-hand-point-up' title='immediate feedback'></i></div>">
<p>Slips detected at runtime, no support for checking lapses and mistakes.
Evaluation offers immediate feedback, making quick error correction possible.</p>
</section>
<section data-characteristics="adoptability-minimal, adoptability-nonexperts, adoptability-unified" data-file="systems/boxer" data-id="dims-adoptability" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-minimize' title='simple, small, specific needs'></i><i class='fa fa-user' title='used by non-experts'></i><i class='fa fa-table-cells-large' title='unified design, provides value after intial learning curve'></i></div>">
<p>Simple and minimal design supports learnability. Unified design makes knowledge reusable.
System is closed from external world and has only limited community and available packages or examples.</p>
</section>
<section data-file="systems/boxer" data-id="summary" data-title="Boxer">
<p>yadda</p>
<p><img src="img/boxer.gif" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/boxer" data-id="index">
<h1>Boxer</h1>
<embed type="application/transclusion" src="content=summary,link=index" />
<p>more here</p>
</section>
<section data-characteristics="interaction-multi, interaction-closed, interaction-principles" data-file="systems/haskell" data-id="dims-interaction" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-forward' title='multiple modes of interaction (build phase)'></i><i class='fa fa-lock' title='closed abstractiosn'></i><i class='fa fa-subscript' title='abstraction from first principles'></i></div>">
<p>Separate editing, compilation and execution modes with feedback at each level.
Abstractions from first-principles (functions, type classes) are opaque during execution.</p>
</section>
<section data-characteristics="notations-primary, notations-complementing" data-file="systems/haskell" data-id="dims-notation" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-trophy' title='has primary notation'></i><i class='fa fa-handshake' title='has complementing notation'></i></div>">
<p>Primary source code notation with secondary infrastructure notations, edited as text.
Rich mostly explicit language with variety of extensions.</p>
</section>
<section data-characteristics="concepts-interface, concepts-minimal, concepts-composable, concepts-nonconvenient" data-file="systems/haskell" data-id="dims-conceptual" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-tbd' title='explicit interface for capturing commondality'></i><i class='fa fa-gem' title='small number of concepts'></i><i class='fa fa-link' title='high composability'></i><i class='fa fa-hand-fist' title='lacks convenience'></i></div>">
<p>Small number of unified concepts (functions, expressions) at odds with outside world.
Composability at expression and type level. Limited set of convenience tools. Type classes for commonality.</p>
</section>
<section data-characteristics="custom-oss, custom-stages, custom-additive" data-file="systems/haskell" data-id="dims-customizability" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-code-pull-request' title='modifiable as oss'></i><i class='fa fa-flag-checkered' title='stage distinction'></i><i class='fa fa-file-circle-plus' title='additive authoring'></i></div>">
<p>Language is fixed, but can theoretically be modified as open-source project with community.
Programs cannot modify themselves nor the system. Type classes allow extensibility at compile-time.</p>
</section>
<section data-characteristics="complexity-gc, complexity-rich" data-file="systems/haskell" data-id="dims-complexity" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-recycle' title='basic language automation like GC'></i><i class='fa fa-building-columns' title='rich complexity structuring (FP, OOP)'></i></div>">
<p>Complexity factored using math-inspired type class hierarchies with type system support.
Automates memory management (GC) and evaluation order (laziness).</p>
</section>
<section data-characteristics="errors-static, errors-code" data-file="systems/haskell" data-id="dims-errors" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-person-military-pointing' title='static error checking'></i><i class='fa fa-code' title='fix errors in code based on error messages'></i></div>">
<p>Strict error checking eliminates lapes and slips and some mistakes at compile time.
Error correction done in text editor, based on non-trivial error messages.</p>
</section>
<section data-characteristics="adoptability-background, adoptability-unified, adoptability-community, adoptability-packages" data-file="systems/haskell" data-id="dims-adoptability" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-infinity' title='advanced background knowledge assumptions'></i><i class='fa fa-table-cells-large' title='unified design, provides value after intial learning curve'></i><i class='fa fa-podcast' title='vibrant community in some sense'></i><i class='fa fa-boxes-packing' title='easy sharing of packages'></i></div>">
<p>Learning requires background knowledge (mathematics), but is supported by community and uniform design.
Closed ecosystem, but with community and diversity of packages.</p>
</section>
<section data-file="systems/haskell" data-id="summary" data-title="Haskell">
<p>yadda</p>
<p><img src="img/haskell.png" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/haskell" data-id="index">
<h1>Haskell</h1>
<embed type="application/transclusion" src="content=summary,link=index" />
<p>more here</p>
</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-dm, interaction-open, interaction-principles, interaction-concrete" data-file="systems/hypercard" data-id="dims-interaction" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-caret-right' title='single mode of interaction'></i><i class='fa fa-circle-play' title='REPL-like execution'></i><i class='fa fa-hand-pointer' title='some kind of direct manipulation'></i><i class='fa fa-lock-open' title='open abstractions'></i><i class='fa fa-subscript' title='abstraction from first principles'></i><i class='fa fa-eye' title='abstraction from concrete'></i></div>">
<p>Direct manipulation for user interface; programmatic scripting with execution feedback loop.
Abstractions on card level using shared backgrounds and transclusion.</p>
</section>
<section data-characteristics="notations-complementing, notations, notations-nonuniform, notations-graphical" data-file="systems/hypercard" data-id="dims-notation" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-handshake' title='has complementing notation'></i><i class='fa fa-arrow-pointer' title='some structure editing'></i><i class='fa fa-bars-staggered' title='non-uniform notation'></i><i class='fa fa-image' title='some graphical notation'></i></div>">
<p>Complementing graphical notation (user interface) with source code in Hypertalk.
Variety of controls and langauge features with tight expression geography in user interface.</p>
</section>
<section data-characteristics="concepts-minimal, concepts-diverse, concepts-noncomposable, concepts-convenient" data-file="systems/hypercard" data-id="dims-conceptual" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-gem' title='small number of concepts'></i><i class='fa fa-shapes' title='variety of diverse concepts'></i><i class='fa fa-link-slash' title='lacks composability'></i><i class='fa fa-toolbox' title='high convenience'></i></div>">
<p>Limited number of domain-specific concepts (cards, user interface elements, scripts).
Partial composability at script level, but limited at card level. Convenient for the given domain.</p>
</section>
<section data-characteristics="concepts-large, custom-closed" data-file="systems/hypercard" data-id="dims-customizability" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-file' title='large concepts'></i><i class='fa fa-square-xmark' title='not modifieable at all'></i></div>">
<p>Cards are editable during execution, but system itself cannot be modified.
Adding only appends new content, but cannot modify existing ones.</p>
</section>
<section data-characteristics="complexity-gc, complexity-domain, complexity-externalized" data-file="systems/hypercard" data-id="dims-complexity" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-recycle' title='basic language automation like GC'></i><i class='fa fa-receipt' title='domain-specific factoring (grid, ui, boxes)'></i><i class='fa fa-satellite-dish' title='lots of externalized complexity'></i></div>">
<p>Basic factoring via language and card abstractions. Underlying system automates user-interface
handling; high-level scripting language offers basic automation (garbage collection).</p>
</section>
<section data-characteristics="errors-static, errors-dynamic, errors-code" data-file="systems/hypercard" data-id="dims-errors" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-person-military-pointing' title='static error checking'></i><i class='fa fa-person-running' title='runtime error checking'></i><i class='fa fa-code' title='fix errors in code based on error messages'></i></div>">
<p>High-level structure prevents many errors by construction. Script slips checked at runtime.
Correction done in code based on an error message.</p>
</section>
<section data-characteristics="adoptability-minimal, adoptability-nonexperts, adoptability-community" data-file="systems/hypercard" data-id="dims-adoptability" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-minimize' title='simple, small, specific needs'></i><i class='fa fa-user' title='used by non-experts'></i><i class='fa fa-podcast' title='vibrant community in some sense'></i></div>">
<p>Focus on specific domain (hypermedia) and graphical interface supports learning. End-users can
progresively become programmers. Closed from external world, but active community sharing examples.</p>
</section>
<section data-file="systems/hypercard" data-id="summary" data-title="Hypercard">
<p>yadda</p>
<p><img src="img/hypercard.jpg" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/hypercard" data-id="index">
<h1>Hypercard</h1>
<embed type="application/transclusion" src="content=summary,link=index" />
<p>more here</p>
</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-open, interaction-principles" data-file="systems/lisp-machines" data-id="dims-interaction" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-caret-right' title='single mode of interaction'></i><i class='fa fa-circle-play' title='REPL-like execution'></i><i class='fa fa-lock-open' title='open abstractions'></i><i class='fa fa-subscript' title='abstraction from first principles'></i></div>">
<p>Integrated execution and editing mode, giving feedback at runtime.
Abstractions constructed using functions are accessible as data.</p>
</section>
<section data-characteristics="notations-primary, notations, notations-uniform" data-file="systems/lisp-machines" data-id="dims-notation" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-trophy' title='has primary notation'></i><i class='fa fa-arrow-pointer' title='some structure editing'></i><i class='fa fa-bars' title='uniform notation'></i></div>">
<p>Very uniform notation with code and data represented as S-expressions
and edited either as text or using structure editor. Use of domain-specific languages.</p>
</section>
<section data-characteristics="concepts-interface, concepts-minimal, concepts-composable, concepts-nonconvenient" data-file="systems/lisp-machines" data-id="dims-conceptual" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-tbd' title='explicit interface for capturing commondality'></i><i class='fa fa-gem' title='small number of concepts'></i><i class='fa fa-link' title='high composability'></i><i class='fa fa-hand-fist' title='lacks convenience'></i></div>">
<p>Small number of unified concepts ("everything is a list") at odds with outside world.
Allows for composability, but lacks convenience ("Lisp curse").</p>
</section>
<section data-characteristics="concepts-large, custom-runtime, custom-addressing, custom-additive, custom-sustainable" data-file="systems/lisp-machines" data-id="dims-customizability" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-file' title='large concepts'></i><i class='fa fa-car-on' title='modifiable while running'></i><i class='fa fa-list-ol' title='clever addressing mechanism'></i><i class='fa fa-file-circle-plus' title='additive authoring'></i><i class='fa fa-arrows-spin' title='self-sustainable'></i></div>">
<p>System can be customized at runtime. Much of the system is written in itself and can be
modified from within itself. Addressing can be done via "advising".</p>
</section>
<section data-characteristics="complexity-gc, complexity-rich" data-file="systems/lisp-machines" data-id="dims-complexity" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-recycle' title='basic language automation like GC'></i><i class='fa fa-building-columns' title='rich complexity structuring (FP, OOP)'></i></div>">
<p>Optional but common factoring mechanisms include functions, CLOS and domain-specific languages.
Basic automation (garbage collection) with more in the context of AI research.</p>
</section>
<section data-characteristics="errors-dynamic, errors-recovery, errors-interactive" data-file="systems/lisp-machines" data-id="dims-errors" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-person-running' title='runtime error checking'></i><i class='fa fa-truck-fast' title='automatic error recovery'></i><i class='fa fa-bug-slash' title='interactive editor/debugger for correction'></i></div>">
<p>Errors detected at runtime and can be corrected immediately in interactive editor/debugger.
More checking can be done via reflection and code analysis.</p>
</section>
<section data-characteristics="adoptability-unified, adoptability-community" data-file="systems/lisp-machines" data-id="dims-adoptability" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-table-cells-large' title='unified design, provides value after intial learning curve'></i><i class='fa fa-podcast' title='vibrant community in some sense'></i></div>">
<p>Steep learning curve, but uniform design makes understanding reusable. Designed for programmers.
Active community, but closed from the external world and limited packages available.</p>
</section>
<section data-file="systems/lisp-machines" data-id="summary" data-title="LISP machines">
<p>yadda</p>
<p><img src="img/lisp-genera.gif" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/lisp-machines" data-id="index" data-title="LISP machines">
<h1>LISP machines</h1>
<p><img src="#left=index" alt="$systems/lisp-machines,summary" /></p>
<p>more here</p>
</section>
<section data-characteristics="interaction-repl, interaction-open, interaction-principles, interaction-concrete" data-file="systems/notebooks" data-id="dims-interaction" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-circle-play' title='REPL-like execution'></i><i class='fa fa-lock-open' title='open abstractions'></i><i class='fa fa-subscript' title='abstraction from first principles'></i><i class='fa fa-eye' title='abstraction from concrete'></i></div>">
<p>Feedback and execution at cell level.
Programmatic abstractions are possible, but manual approach by copying or modifying code is common.</p>
</section>
<section data-characteristics="notations-complementing, notations, notations-nonuniform, notations-graphical" data-file="systems/notebooks" data-id="dims-notation" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-handshake' title='has complementing notation'></i><i class='fa fa-arrow-pointer' title='some structure editing'></i><i class='fa fa-bars-staggered' title='non-uniform notation'></i><i class='fa fa-image' title='some graphical notation'></i></div>">
<p>Literate programming with code, text and outputs, embedded in a notebook as complementing notations.
Document model where notebook is a list of cells.</p>
</section>
<section data-characteristics="concepts-large, concepts-diverse, concepts-noncomposable, concepts-convenient" data-file="systems/notebooks" data-id="dims-conceptual" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-file' title='large concepts'></i><i class='fa fa-shapes' title='variety of diverse concepts'></i><i class='fa fa-link-slash' title='lacks composability'></i><i class='fa fa-toolbox' title='high convenience'></i></div>">
<p>Notebook and cells as "large" concepts with code notions (Python) as "small" concepts.
Composability primarily at code level, but not notebook level. Convenient libraries and tools.</p>
</section>
<section data-characteristics="custom-oss, custom-closed" data-file="systems/notebooks" data-id="dims-customizability" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-code-pull-request' title='modifiable as oss'></i><i class='fa fa-square-xmark' title='not modifieable at all'></i></div>">
<p>System is fixed, but can theoretically be modified as open-source project with community.
Programs cannot modify themselves, notebook or system at runtime.</p>
</section>
<section data-characteristics="complexity-gc, complexity-domain, complexity-externalized" data-file="systems/notebooks" data-id="dims-complexity" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-recycle' title='basic language automation like GC'></i><i class='fa fa-receipt' title='domain-specific factoring (grid, ui, boxes)'></i><i class='fa fa-satellite-dish' title='lots of externalized complexity'></i></div>">
<p>Complexity relegated to complex libraries (pandas, ML libraries, etc.) created outside the system.
Basic language automation (GC) but no automatic recomputation in standard Jupyter setup.</p>
</section>
<section data-characteristics="errors-dynamic, errors-immediate" data-file="systems/notebooks" data-id="dims-errors" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-person-running' title='runtime error checking'></i><i class='fa fa-hand-point-up' title='immediate feedback'></i></div>">
<p>Slips caught at runtime. Limited checking of lapses or domain-specific mistakes.
REPL-evaluation provides quick feedback, making quick error correction possible.</p>
</section>
<section data-characteristics="adoptability-domain, adoptability-nonexperts, adoptability-worse, adoptability-packages, adoptability-community" data-file="systems/notebooks" data-id="dims-adoptability" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-clapperboard' title='focus on a specific application domain'></i><i class='fa fa-user' title='used by non-experts'></i><i class='fa fa-globe' title='compatibility with anything external'></i><i class='fa fa-boxes-packing' title='easy sharing of packages'></i><i class='fa fa-podcast' title='vibrant community in some sense'></i></div>">
<p>Learnability is supported by focus on a specific domain, graphical interface and community.
Notebooks can import a range of community packages and integrate with external systems.</p>
</section>
<section data-file="systems/notebooks" data-id="summary" data-title="Notebooks">
<p>yadda</p>
<p><img src="img/ipython.png" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/notebooks" data-id="index">
<h1>Notebooks</h1>
<embed type="application/transclusion" src="content=summary,link=index" />
<p>more here</p>
</section>
<section data-characteristics="interaction-single, interaction-repl, interaction-open, interaction-principles" data-file="systems/smalltalk" data-id="dims-interaction" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-caret-right' title='single mode of interaction'></i><i class='fa fa-circle-play' title='REPL-like execution'></i><i class='fa fa-lock-open' title='open abstractions'></i><i class='fa fa-subscript' title='abstraction from first principles'></i></div>">
<p>Integrated execution and editing mode, giving feedback at runtime.
Abstractions constructed using objects are accessible via a browser.</p>
</section>
<section data-characteristics="notations-primary, notations, notations-uniform" data-file="systems/smalltalk" data-id="dims-notation" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-trophy' title='has primary notation'></i><i class='fa fa-arrow-pointer' title='some structure editing'></i><i class='fa fa-bars' title='uniform notation'></i></div>">
<p>Primary source code notation with graphical structure editor for object structure.
Secondary overlapping notations can be developed in-system. Small language.</p>
</section>
<section data-characteristics="concepts-interface, concepts-minimal, concepts-composable, concepts-nonconvenient" data-file="systems/smalltalk" data-id="dims-conceptual" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-tbd' title='explicit interface for capturing commondality'></i><i class='fa fa-gem' title='small number of concepts'></i><i class='fa fa-link' title='high composability'></i><i class='fa fa-hand-fist' title='lacks convenience'></i></div>">
<p>Small number of unified concepts ("everything is an object") at odds with outside world.
Everything is composed from small number of primitives, but limits convenience. Structural commonality.</p>
</section>
<section data-characteristics="custom-runtime, custom-addressing, custom-additive, custom-sustainable" data-file="systems/smalltalk" data-id="dims-customizability" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-car-on' title='modifiable while running'></i><i class='fa fa-list-ol' title='clever addressing mechanism'></i><i class='fa fa-file-circle-plus' title='additive authoring'></i><i class='fa fa-arrows-spin' title='self-sustainable'></i></div>">
<p>System can be customized at runtime. Much of the system is written in itself and can be
modified from within itself. Extensibility achieved via object-oriented programming.</p>
</section>
<section data-characteristics="complexity-gc, complexity-rich" data-file="systems/smalltalk" data-id="dims-complexity" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-recycle' title='basic language automation like GC'></i><i class='fa fa-building-columns' title='rich complexity structuring (FP, OOP)'></i></div>">
<p>Factoring using a rich class-based system covering system and application-level features.
Basic automation (garbage collection) with more possible through libraries &amp; via reflection.</p>
</section>
<section data-characteristics="errors-dynamic, errors-interactive" data-file="systems/smalltalk" data-id="dims-errors" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-person-running' title='runtime error checking'></i><i class='fa fa-bug-slash' title='interactive editor/debugger for correction'></i></div>">
<p>Errors detected at runtime and can be corrected immediately in interactive editor/debugger.
Further detection possible via engineering testing tools.</p>
</section>
<section data-characteristics="adoptability-unified, adoptability-nonexperts, adoptability-community" data-file="systems/smalltalk" data-id="dims-adoptability" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-table-cells-large' title='unified design, provides value after intial learning curve'></i><i class='fa fa-user' title='used by non-experts'></i><i class='fa fa-podcast' title='vibrant community in some sense'></i></div>">
<p>Steep learning curve, but uniform design makes understanding reusable. End-users can progressively become programmers.
Active community, but closed world and limited packages.</p>
</section>
<section data-file="systems/smalltalk" data-id="summary" data-title="Smalltalk">
<p>yadda</p>
<p><img src="img/smalltalk-78.png" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/smalltalk" data-id="index">
<h1>Smalltalk</h1>
<embed type="application/transclusion" src="content=summary,link=index" />
<p>more here</p>
</section>
<section data-characteristics="interaction-live, interaction-dm, interaction-open, interaction-concrete" data-file="systems/spreadsheets" data-id="dims-interaction" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-rotate-right' title='some kind of live feedback'></i><i class='fa fa-hand-pointer' title='some kind of direct manipulation'></i><i class='fa fa-lock-open' title='open abstractions'></i><i class='fa fa-eye' title='abstraction from concrete'></i></div>">
<p>Live update when editing. Formulas are always accessible.
Abstraction by generalizing from concrete computation (drag down) or using macros.</p>
</section>
<section data-characteristics="notations-complementing, notations, notations-nonuniform, notations-graphical" data-file="systems/spreadsheets" data-id="dims-notation" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-handshake' title='has complementing notation'></i><i class='fa fa-arrow-pointer' title='some structure editing'></i><i class='fa fa-bars-staggered' title='non-uniform notation'></i><i class='fa fa-image' title='some graphical notation'></i></div>">
<p>Complementing notations with graphical grid, formulas and macros, allowing gradually richer interactions.
Different non-uniform notation at each level.</p>
</section>
<section data-characteristics="concepts-minimal, concepts-composable, concepts-convenient" data-file="systems/spreadsheets" data-id="dims-conceptual" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-gem' title='small number of concepts'></i><i class='fa fa-link' title='high composability'></i><i class='fa fa-toolbox' title='high convenience'></i></div>">
<p>Limited number of domain-specific concepts (sheet, formula, macro).
Computation can be composed and formulas constructed using many convenient built-ins. Structural commonality.</p>
</section>
<section data-characteristics="custom-closed, concepts-large" data-file="systems/spreadsheets" data-id="dims-customizability" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-square-xmark' title='not modifieable at all'></i><i class='fa fa-file' title='large concepts'></i></div>">
<p>Documents are editable during execution, but system itself cannot be modified.
Adding only appends computations, but cannot modify existing ones.</p>
</section>
<section data-characteristics="complexity-fancy, complexity-domain" data-file="systems/spreadsheets" data-id="dims-complexity" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-wand-magic-sparkles' title='advanced automation mechanism of some kind'></i><i class='fa fa-receipt' title='domain-specific factoring (grid, ui, boxes)'></i></div>">
<p>Fixed structure of formulas and grid. High-level language for formulas with automated re-computation.
Programming-by-example provides next-step automation.</p>
</section>
<section data-characteristics="errors-dynamic, errors-immediate" data-file="systems/spreadsheets" data-id="dims-errors" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-person-running' title='runtime error checking'></i><i class='fa fa-hand-point-up' title='immediate feedback'></i></div>">
<p>Slips caught at runtime, but no support for checking lapses or mistakes.
Provides immediate feedback, making quick error correction possible.</p>
</section>
<section data-characteristics="adoptability-domain, adoptability-nonexperts, adoptability-minimal" data-file="systems/spreadsheets" data-id="dims-adoptability" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-clapperboard' title='focus on a specific application domain'></i><i class='fa fa-user' title='used by non-experts'></i><i class='fa fa-minimize' title='simple, small, specific needs'></i></div>">
<p>Domain-focus on specific needs and graphical interface supports learning. End-users can progressively become programmers.
No packaging mechanism, but wide range of samples and community available.</p>
</section>
<section data-file="systems/spreadsheets" data-id="summary" data-title="Spreadsheets">
<p>yadda</p>
<p><img src="img/visicalc.png" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/spreadsheets" data-id="index">
<h1>Spreadsheets</h1>
<embed type="application/transclusion" src="content=summary,link=index" />
<p>more here</p>
</section>
<section data-characteristics="interaction-multi, interaction-repl, interaction-closed, interaction-principles, interaction-concrete" data-file="systems/unix" data-id="dims-interaction" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-forward' title='multiple modes of interaction (build phase)'></i><i class='fa fa-circle-play' title='REPL-like execution'></i><i class='fa fa-lock' title='closed abstractiosn'></i><i class='fa fa-subscript' title='abstraction from first principles'></i><i class='fa fa-eye' title='abstraction from concrete'></i></div>">
<p>Edit, build and execution modes with feedback in each step.
Abstractions include files, memory and processes. Shell allows going from concrete to abstract.</p>
</section>
<section data-characteristics="notations-primary, notations-complementing, notations-nonuniform, notations-concise" data-file="systems/unix" data-id="dims-notation" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-trophy' title='has primary notation'></i><i class='fa fa-handshake' title='has complementing notation'></i><i class='fa fa-bars-staggered' title='non-uniform notation'></i><i class='fa fa-bug' title='concise error-prone'></i></div>">
<p>Primary notation (the C language) with variety of secondary (file system, shell scripts),
all edited via text editor. Admits concise but error-prone notations.</p>
</section>
<section data-characteristics="concepts-large, concepts-composable, concepts-convenient" data-file="systems/unix" data-id="dims-conceptual" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-file' title='large concepts'></i><i class='fa fa-link' title='high composability'></i><i class='fa fa-toolbox' title='high convenience'></i></div>">
<p>Files provide "large" common concepts, but details are open.
Scripting based on small composable tools. Standard libraries and tools offer convenience.</p>
</section>
<section data-characteristics="custom-stages, custom-additive, custom-sustainable" data-file="systems/unix" data-id="dims-customizability" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-flag-checkered' title='stage distinction'></i><i class='fa fa-file-circle-plus' title='additive authoring'></i><i class='fa fa-arrows-spin' title='self-sustainable'></i></div>">
<p>Explicit stage distinction between execution and building, but system is written using its
own notation (C language) and can be modified and rebuilt from within itself. Limited
modifiability at runtime.</p>
</section>
<section data-characteristics="complexity-manual, complexity-lowlevel" data-file="systems/unix" data-id="dims-complexity" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-wrench' title='everything manual, no automation at all'></i><i class='fa fa-gears' title='low level infrastructure (files, http)'></i></div>">
<p>Defines low-level infrastructure (hardware abstractions) and large object structure (files, processes);
small-scale factoring and automation left to the user and/or application.</p>
</section>
<section data-characteristics="errors-shootfoot, errors-custom" data-file="systems/unix" data-id="dims-errors" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-gun' title='no error checking'></i><i class='fa fa-person-rays' title='implement custom detection/correction'></i></div>">
<p>Error detection left to the system user. Low-level primitives make it possible to
automate detection and response via custom mechanisms.</p>
</section>
<section data-characteristics="adoptability-background, adoptability-worse, adoptability-community" data-file="systems/unix" data-id="dims-adoptability" data-shade="shade2" data-title="<div class='shade2'><i class='fa fa-infinity' title='advanced background knowledge assumptions'></i><i class='fa fa-globe' title='compatibility with anything external'></i><i class='fa fa-podcast' title='vibrant community in some sense'></i></div>">
<p>Requires background knowledge (system-level), but supported by active community.
Openness allows integration with the external world; diversity of packages available.</p>
</section>
<section data-file="systems/unix" data-id="summary" data-title="UNIX">
<p>yadda</p>
<p><img src="img/unix-6.png" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/unix" data-id="index">
<h1>UNIX</h1>
<embed type="application/transclusion" src="content=summary,link=index" />
<p>more here</p>
</section>
<section data-characteristics="interaction-multi, interaction-repl, interaction-live, interaction-closed, interaction-open, interaction-principles" data-file="systems/web" data-id="dims-interaction" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-forward' title='multiple modes of interaction (build phase)'></i><i class='fa fa-circle-play' title='REPL-like execution'></i><i class='fa fa-rotate-right' title='some kind of live feedback'></i><i class='fa fa-lock' title='closed abstractiosn'></i><i class='fa fa-lock-open' title='open abstractions'></i><i class='fa fa-subscript' title='abstraction from first principles'></i></div>">
<p>Edit and refresh mode with state visible in DOM browser and live developer tools.
Code abstractions are closed, but style abstractions more transparent.</p>
</section>
<section data-characteristics="notations-complementing, notations-nonuniform" data-file="systems/web" data-id="dims-notation" data-shade="shade3" data-title="<div class='shade3'><i class='fa fa-handshake' title='has complementing notation'></i><i class='fa fa-bars-staggered' title='non-uniform notation'></i></div>">
<p>Diversity of text-based highly non-uniform notations (HTML, JavaScript, CSS) with limited structure editing for debugging (DOM).</p>
</section>
<section data-characteristics="concepts-large, concepts-diverse, concepts-domain, concepts-convenient" data-file="systems/web" data-id="dims-conceptual" data-shade="shade1" data-title="<div class='shade1'><i class='fa fa-file' title='large concepts'></i><i class='fa fa-shapes' title='variety of diverse concepts'></i><i class='fa fa-flask' title='domain specific concepts'></i><i class='fa fa-toolbox' title='high convenience'></i></div>">
<p>Improvised mix of open "large" concepts (HTTP) and specific ones (DOM).
Many convenient libraries and tools with low commonality and varying composability.</p>
</section>
<section data-characteristics="custom-runtime, custom-closed, custom-addressing, custom-additive" data-file="systems/web" data-id="dims-customizability" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-car-on' title='modifiable while running'></i><i class='fa fa-square-xmark' title='not modifieable at all'></i><i class='fa fa-list-ol' title='clever addressing mechanism'></i><i class='fa fa-file-circle-plus' title='additive authoring'></i></div>">
<p>Basic infrastructure (browser, protocols) are fixed. Individual applications can have
a large degree of modifiability (via dynamic scripting). CSS provides powerful addressing.</p>
</section>
<section data-characteristics="complexity-gc, complexity-rich, complexity-lowlevel, complexity-domain" data-file="systems/web" data-id="dims-complexity" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-recycle' title='basic language automation like GC'></i><i class='fa fa-building-columns' title='rich complexity structuring (FP, OOP)'></i><i class='fa fa-gears' title='low level infrastructure (files, http)'></i><i class='fa fa-receipt' title='domain-specific factoring (grid, ui, boxes)'></i></div>">
<p>Factoring via high-level languages (JavaScript), rule-based systems (CSS) and standard interfaces
(W3C specifications). Automation at basic level (garbage collection) and in declarative domains (CSS).</p>
</section>
<section data-characteristics="errors-custom, errors-recovery, errors-code, errors-interactive" data-file="systems/web" data-id="dims-errors" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-person-rays' title='implement custom detection/correction'></i><i class='fa fa-truck-fast' title='automatic error recovery'></i><i class='fa fa-code' title='fix errors in code based on error messages'></i><i class='fa fa-bug-slash' title='interactive editor/debugger for correction'></i></div>">
<p>Generally aims to do the best thing possible (automatic recovery) on errors.
Direct error correction can be done in browser tools, but not permanent.</p>
</section>
<section data-characteristics="adoptability-worse, adoptability-packages, adoptability-community" data-file="systems/web" data-id="dims-adoptability" data-shade="shade4" data-title="<div class='shade4'><i class='fa fa-globe' title='compatibility with anything external'></i><i class='fa fa-boxes-packing' title='easy sharing of packages'></i><i class='fa fa-podcast' title='vibrant community in some sense'></i></div>">
<p>Web has a diversity of technologies; learnability is mainly achieved through community.
The diversified web ecosystem allows for the integration with external systems.</p>
</section>
<section data-file="systems/web" data-id="summary" data-title="Web platform">
<p>yadda</p>
<p><img src="img/web-ie5.png" alt="" /></p>
</section>
<section data-class="systems" data-file="systems/web" data-id="index">
<h1>Web platform</h1>
<embed type="application/transclusion" src="content=summary,link=index" />
<p>more here</p>
</section>

  </article>
  <div id="display">
    <div id="splash" class="display"></div>
    <div id="image" class="display"></div>
    <div id="top" class="display"></div>
    <div id="right" class="display"></div>
    <div id="left" class="display"></div>
    <div id="big" class="display"></div>
    <div id="footer" class="display"></div>
  </div>
  <script type="application/template" id="display-template">    
    <div class="display-wrapper [CLASS]">
      <div class="display-title">
        [TITLE]
      </div>
      <div class="display-body">
        [CONTENT]
      </div>
    </div>
  </script>
  <script type="application/template" id="transclusion-content-template">    
    <div class="transclusion">
      <div class="title">
        [TITLE]
      </div>
      <div class="body">
        [CONTENT]
        <div style="clear:both"></div>
      </div>
    </div>
  </script>
  <script src="bundle.js"></script>
</body>
</html>
